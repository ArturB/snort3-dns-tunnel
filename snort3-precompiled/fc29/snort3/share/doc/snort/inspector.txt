
=== appid


What: application and service identification

Type: inspector

Usage: context

Configuration: 

* int *appid.memcap* = 1048576: max size of the service cache before we start pruning the cache { 1024:maxSZ }
* bool *appid.log_stats* = false: enable logging of appid statistics
* int *appid.app_stats_period* = 300: time period for collecting and logging appid statistics { 1:max32 }
* int *appid.app_stats_rollover_size* = 20971520: max file size for appid stats before rolling over the log file { 0:max32 }
* int *appid.app_stats_rollover_time* = 86400: max time period for collection appid stats before rolling over the log file { 0:max31 }
* string *appid.app_detector_dir*: directory to load appid detectors from
* int *appid.instance_id* = 0: instance id - ignored { 0:max32 }
* bool *appid.debug* = false: enable appid debug logging
* bool *appid.dump_ports* = false: enable dump of appid port information
* string *appid.tp_appid_path*: path to third party appid dynamic library
* string *appid.tp_appid_config*: path to third party appid configuration file
* bool *appid.tp_appid_stats_enable*: enable collection of stats and print stats on exit in third party module
* bool *appid.tp_appid_config_dump*: print third party configuration on startup
* bool *appid.log_all_sessions* = false: enable logging of all appid sessions
* int *appid.trace*: mask for enabling debug traces in module { 0:max53 }

Commands: 

* *appid.enable_debug*(proto, src_ip, src_port, dst_ip, dst_port): enable appid debugging
* *appid.disable_debug*(): disable appid debugging

Peg counts: 

* *appid.packets*: count of packets received (sum)
* *appid.processed_packets*: count of packets processed (sum)
* *appid.ignored_packets*: count of packets ignored (sum)
* *appid.total_sessions*: count of sessions created (sum)
* *appid.appid_unknown*: count of sessions where appid could not be determined (sum)

=== arp_spoof


What: detect ARP attacks and anomalies

Type: inspector

Usage: inspect

Configuration: 

* ip4 *`arp_spoof.hosts[].ip`*: host ip address
* mac *`arp_spoof.hosts[].mac`*: host mac address

Rules: 

* *112:1* (arp_spoof) unicast ARP request
* *112:2* (arp_spoof) ethernet/ARP mismatch request for source
* *112:3* (arp_spoof) ethernet/ARP mismatch request for destination
* *112:4* (arp_spoof) attempted ARP cache overwrite attack

Peg counts: 

* *arp_spoof.packets*: total packets (sum)

=== back_orifice


What: back orifice detection

Type: inspector

Usage: inspect

Rules: 

* *105:1* (back_orifice) BO traffic detected
* *105:2* (back_orifice) BO client traffic detected
* *105:3* (back_orifice) BO server traffic detected
* *105:4* (back_orifice) BO Snort buffer attack

Peg counts: 

* *back_orifice.packets*: total packets (sum)

=== binder


What: configure processing based on CIDRs, ports, services, etc.

Type: inspector

Usage: inspect

Configuration: 

* int *`binder[].when.ips_policy_id`* = 0: unique ID for selection of this config by external logic { 0:max32 }
* bit_list *`binder[].when.ifaces`*: list of interface indices { 255 }
* bit_list *`binder[].when.vlans`*: list of VLAN IDs { 4095 }
* addr_list *`binder[].when.nets`*: list of networks
* addr_list *`binder[].when.src_nets`*: list of source networks
* addr_list *`binder[].when.dst_nets`*: list of destination networks
* enum *`binder[].when.proto`*: protocol { any | ip | icmp | tcp | udp | user | file }
* bit_list *`binder[].when.ports`*: list of ports { 65535 }
* bit_list *`binder[].when.src_ports`*: list of source ports { 65535 }
* bit_list *`binder[].when.dst_ports`*: list of destination ports { 65535 }
* bit_list *`binder[].when.zones`*: zones { 63 }
* bit_list *`binder[].when.src_zone`*: source zone { 63 }
* bit_list *`binder[].when.dst_zone`*: destination zone { 63 }
* enum *`binder[].when.role`* = any: use the given configuration on one or any end of a session { client | server | any }
* string *`binder[].when.service`*: override default configuration
* enum *`binder[].use.action`* = inspect: what to do with matching traffic { reset | block | allow | inspect }
* string *`binder[].use.file`*: use configuration in given file
* string *`binder[].use.inspection_policy`*: use inspection policy from given file
* string *`binder[].use.ips_policy`*: use ips policy from given file
* string *`binder[].use.network_policy`*: use network policy from given file
* string *`binder[].use.service`*: override automatic service identification
* string *`binder[].use.type`*: select module for binding
* string *`binder[].use.name`*: symbol name (defaults to type)

Peg counts: 

* *binder.packets*: initial bindings (sum)
* *binder.resets*: reset bindings (sum)
* *binder.blocks*: block bindings (sum)
* *binder.allows*: allow bindings (sum)
* *binder.inspects*: inspect bindings (sum)

=== dce_http_proxy


What: dce over http inspection - client to/from proxy

Type: inspector

Usage: inspect

Peg counts: 

* *dce_http_proxy.http_proxy_sessions*: successful http proxy sessions (sum)
* *dce_http_proxy.http_proxy_session_failures*: failed http proxy sessions (sum)

=== dce_http_server


What: dce over http inspection - proxy to/from server

Type: inspector

Usage: inspect

Peg counts: 

* *dce_http_server.http_server_sessions*: successful http server sessions (sum)
* *dce_http_server.http_server_session_failures*: failed http server sessions (sum)

=== dce_smb


What: dce over smb inspection

Type: inspector

Usage: inspect

Configuration: 

* bool *dce_smb.limit_alerts* = true: limit DCE alert to at most one per signature per flow
* bool *dce_smb.disable_defrag* = false: disable DCE/RPC defragmentation
* int *dce_smb.max_frag_len* = 65535: maximum fragment size for defragmentation { 1514:65535 }
* int *dce_smb.reassemble_threshold* = 0: minimum bytes received before performing reassembly { 0:65535 }
* enum *dce_smb.smb_fingerprint_policy* = none: target based SMB policy to use { none | client |  server | both  }
* enum *dce_smb.policy* = WinXP: target based policy to use { Win2000 |  WinXP | WinVista | Win2003 | Win2008 | Win7 | Samba | Samba-3.0.37 | Samba-3.0.22 | Samba-3.0.20 }
* int *dce_smb.smb_max_chain* = 3: SMB max chain size { 0:255 }
* int *dce_smb.smb_max_compound* = 3: SMB max compound size { 0:255 }
* multi *dce_smb.valid_smb_versions* = all: valid SMB versions { v1 | v2 | all }
* enum *dce_smb.smb_file_inspection* = off: SMB file inspection { off | on | only }
* int *dce_smb.smb_file_depth* = 16384: SMB file depth for file data { -1:32767 }
* string *dce_smb.smb_invalid_shares*: SMB shares to alert on 
* bool *dce_smb.smb_legacy_mode* = false: inspect only SMBv1
* int *dce_smb.trace*: mask for enabling debug traces in module { 0:max53 }

Rules: 

* *133:2* (dce_smb) SMB - bad NetBIOS session service session type
* *133:3* (dce_smb) SMB - bad SMB message type
* *133:4* (dce_smb) SMB - bad SMB Id (not \xffSMB for SMB1 or not \xfeSMB for SMB2)
* *133:5* (dce_smb) SMB - bad word count or structure size
* *133:6* (dce_smb) SMB - bad byte count
* *133:7* (dce_smb) SMB - bad format type
* *133:8* (dce_smb) SMB - bad offset
* *133:9* (dce_smb) SMB - zero total data count
* *133:10* (dce_smb) SMB - NetBIOS data length less than SMB header length
* *133:11* (dce_smb) SMB - remaining NetBIOS data length less than command length
* *133:12* (dce_smb) SMB - remaining NetBIOS data length less than command byte count
* *133:13* (dce_smb) SMB - remaining NetBIOS data length less than command data size
* *133:14* (dce_smb) SMB - remaining total data count less than this command data size
* *133:15* (dce_smb) SMB - total data sent (STDu64) greater than command total data expected
* *133:16* (dce_smb) SMB - byte count less than command data size (STDu64)
* *133:17* (dce_smb) SMB - invalid command data size for byte count
* *133:18* (dce_smb) SMB - excessive tree connect requests with pending tree connect responses
* *133:19* (dce_smb) SMB - excessive read requests with pending read responses
* *133:20* (dce_smb) SMB - excessive command chaining
* *133:21* (dce_smb) SMB - multiple chained tree connect requests
* *133:22* (dce_smb) SMB - multiple chained tree connect requests
* *133:23* (dce_smb) SMB - chained/compounded login followed by logoff
* *133:24* (dce_smb) SMB - chained/compounded tree connect followed by tree disconnect
* *133:25* (dce_smb) SMB - chained/compounded open pipe followed by close pipe
* *133:26* (dce_smb) SMB - invalid share access
* *133:44* (dce_smb) SMB - invalid SMB version 1 seen
* *133:45* (dce_smb) SMB - invalid SMB version 2 seen
* *133:46* (dce_smb) SMB - invalid user, tree connect, file binding
* *133:47* (dce_smb) SMB - excessive command compounding
* *133:48* (dce_smb) SMB - zero data count
* *133:50* (dce_smb) SMB - maximum number of outstanding requests exceeded
* *133:51* (dce_smb) SMB - outstanding requests with same MID
* *133:52* (dce_smb) SMB - deprecated dialect negotiated
* *133:53* (dce_smb) SMB - deprecated command used
* *133:54* (dce_smb) SMB - unusual command used
* *133:55* (dce_smb) SMB - invalid setup count for command
* *133:56* (dce_smb) SMB - client attempted multiple dialect negotiations on session
* *133:57* (dce_smb) SMB - client attempted to create or set a file's attributes to readonly/hidden/system
* *133:58* (dce_smb) SMB - file offset provided is greater than file size specified
* *133:59* (dce_smb) SMB - next command specified in SMB2 header is beyond payload boundary

Peg counts: 

* *dce_smb.events*: total events (sum)
* *dce_smb.pdus*: total connection-oriented PDUs (sum)
* *dce_smb.binds*: total connection-oriented binds (sum)
* *dce_smb.bind_acks*: total connection-oriented binds acks (sum)
* *dce_smb.alter_contexts*: total connection-oriented alter contexts (sum)
* *dce_smb.alter_context_responses*: total connection-oriented alter context responses (sum)
* *dce_smb.bind_naks*: total connection-oriented bind naks (sum)
* *dce_smb.requests*: total connection-oriented requests (sum)
* *dce_smb.responses*: total connection-oriented responses (sum)
* *dce_smb.cancels*: total connection-oriented cancels (sum)
* *dce_smb.orphaned*: total connection-oriented orphaned (sum)
* *dce_smb.faults*: total connection-oriented faults (sum)
* *dce_smb.auth3s*: total connection-oriented auth3s (sum)
* *dce_smb.shutdowns*: total connection-oriented shutdowns (sum)
* *dce_smb.rejects*: total connection-oriented rejects (sum)
* *dce_smb.ms_rpc_http_pdus*: total connection-oriented MS requests to send RPC over HTTP (sum)
* *dce_smb.other_requests*: total connection-oriented other requests (sum)
* *dce_smb.other_responses*: total connection-oriented other responses (sum)
* *dce_smb.request_fragments*: total connection-oriented request fragments (sum)
* *dce_smb.response_fragments*: total connection-oriented response fragments (sum)
* *dce_smb.client_max_fragment_size*: connection-oriented client maximum fragment size (sum)
* *dce_smb.client_min_fragment_size*: connection-oriented client minimum fragment size (sum)
* *dce_smb.client_segs_reassembled*: total connection-oriented client segments reassembled (sum)
* *dce_smb.client_frags_reassembled*: total connection-oriented client fragments reassembled (sum)
* *dce_smb.server_max_fragment_size*: connection-oriented server maximum fragment size (sum)
* *dce_smb.server_min_fragment_size*: connection-oriented server minimum fragment size (sum)
* *dce_smb.server_segs_reassembled*: total connection-oriented server segments reassembled (sum)
* *dce_smb.server_frags_reassembled*: total connection-oriented server fragments reassembled (sum)
* *dce_smb.sessions*: total smb sessions (sum)
* *dce_smb.packets*: total smb packets (sum)
* *dce_smb.ignored_bytes*: total ignored bytes (sum)
* *dce_smb.smb_client_segs_reassembled*: total smb client segments reassembled (sum)
* *dce_smb.smb_server_segs_reassembled*: total smb server segments reassembled (sum)
* *dce_smb.max_outstanding_requests*: total smb maximum outstanding requests (sum)
* *dce_smb.files_processed*: total smb files processed (sum)
* *dce_smb.smbv2_create*: total number of SMBv2 create packets seen (sum)
* *dce_smb.smbv2_write*: total number of SMBv2 write packets seen (sum)
* *dce_smb.smbv2_read*: total number of SMBv2 read packets seen (sum)
* *dce_smb.smbv2_set_info*: total number of SMBv2 set info packets seen (sum)
* *dce_smb.smbv2_tree_connect*: total number of SMBv2 tree connect packets seen (sum)
* *dce_smb.smbv2_tree_disconnect*: total number of SMBv2 tree disconnect packets seen (sum)
* *dce_smb.smbv2_close*: total number of SMBv2 close packets seen (sum)
* *dce_smb.concurrent_sessions*: total concurrent sessions (now)
* *dce_smb.max_concurrent_sessions*: maximum concurrent sessions (max)

=== dce_tcp


What: dce over tcp inspection

Type: inspector

Usage: inspect

Configuration: 

* bool *dce_tcp.limit_alerts* = true: limit DCE alert to at most one per signature per flow
* bool *dce_tcp.disable_defrag* = false: disable DCE/RPC defragmentation
* int *dce_tcp.max_frag_len* = 65535: maximum fragment size for defragmentation { 1514:65535 }
* int *dce_tcp.reassemble_threshold* = 0: minimum bytes received before performing reassembly { 0:65535 }
* enum *dce_tcp.policy* = WinXP: target based policy to use { Win2000 |  WinXP | WinVista | Win2003 | Win2008 | Win7 | Samba | Samba-3.0.37 | Samba-3.0.22 | Samba-3.0.20 }

Rules: 

* *133:27* (dce_tcp) connection oriented DCE/RPC - invalid major version
* *133:28* (dce_tcp) connection oriented DCE/RPC - invalid minor version
* *133:29* (dce_tcp) connection-oriented DCE/RPC - invalid PDU type
* *133:30* (dce_tcp) connection-oriented DCE/RPC - fragment length less than header size
* *133:31* (dce_tcp) connection-oriented DCE/RPC - remaining fragment length less than size needed
* *133:32* (dce_tcp) connection-oriented DCE/RPC - no context items specified
* *133:33* (dce_tcp) connection-oriented DCE/RPC -no transfer syntaxes specified
* *133:34* (dce_tcp) connection-oriented DCE/RPC - fragment length on non-last fragment less than maximum negotiated fragment transmit size for client
* *133:35* (dce_tcp) connection-oriented DCE/RPC - fragment length greater than maximum negotiated fragment transmit size
* *133:36* (dce_tcp) connection-oriented DCE/RPC - alter context byte order different from bind
* *133:37* (dce_tcp) connection-oriented DCE/RPC - call id of non first/last fragment different from call id established for fragmented request
* *133:38* (dce_tcp) connection-oriented DCE/RPC - opnum of non first/last fragment different from opnum established for fragmented request
* *133:39* (dce_tcp) connection-oriented DCE/RPC - context id of non first/last fragment different from context id established for fragmented request

Peg counts: 

* *dce_tcp.events*: total events (sum)
* *dce_tcp.pdus*: total connection-oriented PDUs (sum)
* *dce_tcp.binds*: total connection-oriented binds (sum)
* *dce_tcp.bind_acks*: total connection-oriented binds acks (sum)
* *dce_tcp.alter_contexts*: total connection-oriented alter contexts (sum)
* *dce_tcp.alter_context_responses*: total connection-oriented alter context responses (sum)
* *dce_tcp.bind_naks*: total connection-oriented bind naks (sum)
* *dce_tcp.requests*: total connection-oriented requests (sum)
* *dce_tcp.responses*: total connection-oriented responses (sum)
* *dce_tcp.cancels*: total connection-oriented cancels (sum)
* *dce_tcp.orphaned*: total connection-oriented orphaned (sum)
* *dce_tcp.faults*: total connection-oriented faults (sum)
* *dce_tcp.auth3s*: total connection-oriented auth3s (sum)
* *dce_tcp.shutdowns*: total connection-oriented shutdowns (sum)
* *dce_tcp.rejects*: total connection-oriented rejects (sum)
* *dce_tcp.ms_rpc_http_pdus*: total connection-oriented MS requests to send RPC over HTTP (sum)
* *dce_tcp.other_requests*: total connection-oriented other requests (sum)
* *dce_tcp.other_responses*: total connection-oriented other responses (sum)
* *dce_tcp.request_fragments*: total connection-oriented request fragments (sum)
* *dce_tcp.response_fragments*: total connection-oriented response fragments (sum)
* *dce_tcp.client_max_fragment_size*: connection-oriented client maximum fragment size (sum)
* *dce_tcp.client_min_fragment_size*: connection-oriented client minimum fragment size (sum)
* *dce_tcp.client_segs_reassembled*: total connection-oriented client segments reassembled (sum)
* *dce_tcp.client_frags_reassembled*: total connection-oriented client fragments reassembled (sum)
* *dce_tcp.server_max_fragment_size*: connection-oriented server maximum fragment size (sum)
* *dce_tcp.server_min_fragment_size*: connection-oriented server minimum fragment size (sum)
* *dce_tcp.server_segs_reassembled*: total connection-oriented server segments reassembled (sum)
* *dce_tcp.server_frags_reassembled*: total connection-oriented server fragments reassembled (sum)
* *dce_tcp.tcp_sessions*: total tcp sessions (sum)
* *dce_tcp.tcp_packets*: total tcp packets (sum)
* *dce_tcp.concurrent_sessions*: total concurrent sessions (now)
* *dce_tcp.max_concurrent_sessions*: maximum concurrent sessions (max)

=== dce_udp


What: dce over udp inspection

Type: inspector

Usage: inspect

Configuration: 

* bool *dce_udp.limit_alerts* = true: limit DCE alert to at most one per signature per flow
* bool *dce_udp.disable_defrag* = false: disable DCE/RPC defragmentation
* int *dce_udp.max_frag_len* = 65535: maximum fragment size for defragmentation { 1514:65535 }
* int *dce_udp.trace*: mask for enabling debug traces in module { 0:max53 }

Rules: 

* *133:40* (dce_udp) connection-less DCE/RPC - invalid major version
* *133:41* (dce_udp) connection-less DCE/RPC - invalid PDU type
* *133:42* (dce_udp) connection-less DCE/RPC - data length less than header size
* *133:43* (dce_udp) connection-less DCE/RPC - bad sequence number

Peg counts: 

* *dce_udp.events*: total events (sum)
* *dce_udp.udp_sessions*: total udp sessions (sum)
* *dce_udp.udp_packets*: total udp packets (sum)
* *dce_udp.requests*: total connection-less requests (sum)
* *dce_udp.acks*: total connection-less acks (sum)
* *dce_udp.cancels*: total connection-less cancels (sum)
* *dce_udp.client_facks*: total connection-less client facks (sum)
* *dce_udp.ping*: total connection-less ping (sum)
* *dce_udp.responses*: total connection-less responses (sum)
* *dce_udp.rejects*: total connection-less rejects (sum)
* *dce_udp.cancel_acks*: total connection-less cancel acks (sum)
* *dce_udp.server_facks*: total connection-less server facks (sum)
* *dce_udp.faults*: total connection-less faults (sum)
* *dce_udp.no_calls*: total connection-less no calls (sum)
* *dce_udp.working*: total connection-less working (sum)
* *dce_udp.other_requests*: total connection-less other requests (sum)
* *dce_udp.other_responses*: total connection-less other responses (sum)
* *dce_udp.fragments*: total connection-less fragments (sum)
* *dce_udp.max_fragment_size*: connection-less maximum fragment size (sum)
* *dce_udp.frags_reassembled*: total connection-less fragments reassembled (sum)
* *dce_udp.max_seqnum*: max connection-less seqnum (sum)
* *dce_udp.concurrent_sessions*: total concurrent sessions (now)
* *dce_udp.max_concurrent_sessions*: maximum concurrent sessions (max)

=== dnp3


What: dnp3 inspection

Type: inspector

Usage: inspect

Configuration: 

* bool *dnp3.check_crc* = false: validate checksums in DNP3 link layer frames

Rules: 

* *145:1* (dnp3) DNP3 link-layer frame contains bad CRC
* *145:2* (dnp3) DNP3 link-layer frame was dropped
* *145:3* (dnp3) DNP3 transport-layer segment was dropped during reassembly
* *145:4* (dnp3) DNP3 reassembly buffer was cleared without reassembling a complete message
* *145:5* (dnp3) DNP3 link-layer frame uses a reserved address
* *145:6* (dnp3) DNP3 application-layer fragment uses a reserved function code

Peg counts: 

* *dnp3.total_packets*: total packets (sum)
* *dnp3.udp_packets*: total udp packets (sum)
* *dnp3.tcp_pdus*: total tcp pdus (sum)
* *dnp3.dnp3_link_layer_frames*: total dnp3 link layer frames (sum)
* *dnp3.dnp3_application_pdus*: total dnp3 application pdus (sum)
* *dnp3.concurrent_sessions*: total concurrent dnp3 sessions (now)
* *dnp3.max_concurrent_sessions*: maximum concurrent dnp3 sessions (max)

=== dns


What: dns inspection

Type: inspector

Usage: inspect

Rules: 

* *131:1* (dns) obsolete DNS RR types
* *131:2* (dns) experimental DNS RR types
* *131:3* (dns) DNS client rdata txt overflow

Peg counts: 

* *dns.packets*: total packets processed (sum)
* *dns.requests*: total dns requests (sum)
* *dns.responses*: total dns responses (sum)
* *dns.concurrent_sessions*: total concurrent dns sessions (now)
* *dns.max_concurrent_sessions*: maximum concurrent dns sessions (max)

=== file_id


What: configure file identification

Type: inspector

Usage: global

Configuration: 

* int *file_id.type_depth* = 1460: stop type ID at this point { 0:max53 }
* int *file_id.signature_depth* = 10485760: stop signature at this point { 0:max53 }
* int *file_id.block_timeout* = 86400: stop blocking after this many seconds { 0:max31 }
* int *file_id.lookup_timeout* = 2: give up on lookup after this many seconds { 0:max31 }
* bool *file_id.block_timeout_lookup* = false: block if lookup times out
* int *file_id.capture_memcap* = 100: memcap for file capture in megabytes { 0:max53 }
* int *file_id.capture_max_size* = 1048576: stop file capture beyond this point { 0:max53 }
* int *file_id.capture_min_size* = 0: stop file capture if file size less than this { 0:max53 }
* int *file_id.capture_block_size* = 32768: file capture block size in bytes { 8:max53 }
* int *file_id.max_files_cached* = 65536: maximal number of files cached in memory { 8:max53 }
* bool *file_id.enable_type* = true: enable type ID
* bool *file_id.enable_signature* = true: enable signature calculation
* bool *file_id.enable_capture* = false: enable file capture
* int *file_id.show_data_depth* = 100: print this many octets { 0:max53 }
* int *`file_id.file_rules[].rev`* = 0: rule revision { 0:max32 }
* string *`file_id.file_rules[].msg`*: information about the file type
* string *`file_id.file_rules[].type`*: file type name
* int *`file_id.file_rules[].id`* = 0: file type id { 0:max32 }
* string *`file_id.file_rules[].category`*: file type category
* string *`file_id.file_rules[].group`*: comma separated list of groups associated with file type
* string *`file_id.file_rules[].version`*: file type version
* string *`file_id.file_rules[].magic[].content`*: file magic content
* int *`file_id.file_rules[].magic[].offset`* = 0: file magic offset { 0:max32 }
* int *`file_id.file_policy[].when.file_type_id`* = 0: unique ID for file type in file magic rule { 0:max32 }
* string *`file_id.file_policy[].when.sha256`*: SHA 256
* enum *`file_id.file_policy[].use.verdict`* = unknown: what to do with matching traffic { unknown | log | stop | block | reset  }
* bool *`file_id.file_policy[].use.enable_file_type`* = false: true/false -> enable/disable file type identification
* bool *`file_id.file_policy[].use.enable_file_signature`* = false: true/false -> enable/disable file signature
* bool *`file_id.file_policy[].use.enable_file_capture`* = false: true/false -> enable/disable file capture
* bool *file_id.trace_type* = false: enable runtime dump of type info
* bool *file_id.trace_signature* = false: enable runtime dump of signature info
* bool *file_id.trace_stream* = false: enable runtime dump of file data
* int *file_id.verdict_delay* = 0: number of queries to return final verdict { 0:max53 }

Peg counts: 

* *file_id.total_files*: number of files processed (sum)
* *file_id.total_file_data*: number of file data bytes processed (sum)
* *file_id.cache_failures*: number of file cache add failures (sum)

=== file_log


What: log file event to file.log

Type: inspector

Usage: inspect

Configuration: 

* bool *file_log.log_pkt_time* = true: log the packet time when event generated
* bool *file_log.log_sys_time* = false: log the system time when event generated

Peg counts: 

* *file_log.total_events*: total file events (sum)

=== ftp_client


What: FTP client configuration module for use with ftp_server

Type: inspector

Usage: inspect

Configuration: 

* bool *ftp_client.bounce* = false: check for bounces
* addr *`ftp_client.bounce_to[].address`* = 1.0.0.0/32: allowed IP address in CIDR format
* port *`ftp_client.bounce_to[].port`* = 20: allowed port
* port *`ftp_client.bounce_to[].last_port`*: optional allowed range from port to last_port inclusive
* bool *ftp_client.ignore_telnet_erase_cmds* = false: ignore erase character and erase line commands when normalizing
* int *ftp_client.max_resp_len* = 4294967295: maximum FTP response accepted by client { 0:max32 }
* bool *ftp_client.telnet_cmds* = false: detect Telnet escape sequences on FTP control channel

=== ftp_data


What: FTP data channel handler

Type: inspector

Usage: inspect

Peg counts: 

* *ftp_data.packets*: total packets (sum)

=== ftp_server


What: main FTP module; ftp_client should also be configured

Type: inspector

Usage: inspect

Configuration: 

* string *ftp_server.chk_str_fmt*: check the formatting of the given commands
* string *ftp_server.data_chan_cmds*: check the formatting of the given commands
* string *ftp_server.data_rest_cmds*: check the formatting of the given commands
* string *ftp_server.data_xfer_cmds*: check the formatting of the given commands
* string *`ftp_server.directory_cmds[].dir_cmd`*: directory command
* int *`ftp_server.directory_cmds[].rsp_code`* = 200: expected successful response code for command { 200:max32 }
* string *ftp_server.file_put_cmds*: check the formatting of the given commands
* string *ftp_server.file_get_cmds*: check the formatting of the given commands
* string *ftp_server.encr_cmds*: check the formatting of the given commands
* string *ftp_server.login_cmds*: check the formatting of the given commands
* bool *ftp_server.check_encrypted* = false: check for end of encryption
* string *`ftp_server.cmd_validity[].command`*: command string
* string *`ftp_server.cmd_validity[].format`*: format specification
* int *`ftp_server.cmd_validity[].length`* = 0: specify non-default maximum for command { 0:max32 }
* int *ftp_server.def_max_param_len* = 100: default maximum length of commands handled by server; 0 is unlimited { 1:max32 }
* bool *ftp_server.encrypted_traffic* = false: check for encrypted Telnet and FTP
* string *ftp_server.ftp_cmds*: specify additional commands supported by server beyond RFC 959
* bool *ftp_server.ignore_data_chan* = false: do not inspect FTP data channels
* bool *ftp_server.ignore_telnet_erase_cmds* = false: ignore erase character and erase line commands when normalizing
* bool *ftp_server.print_cmds* = false: print command configurations on start up
* bool *ftp_server.telnet_cmds* = false: detect Telnet escape sequences of FTP control channel

Rules: 

* *125:1* (ftp_server) TELNET cmd on FTP command channel
* *125:2* (ftp_server) invalid FTP command
* *125:3* (ftp_server) FTP command parameters were too long
* *125:4* (ftp_server) FTP command parameters were malformed
* *125:5* (ftp_server) FTP command parameters contained potential string format
* *125:6* (ftp_server) FTP response message was too long
* *125:7* (ftp_server) FTP traffic encrypted
* *125:8* (ftp_server) FTP bounce attempt
* *125:9* (ftp_server) evasive (incomplete) TELNET cmd on FTP command channel

Peg counts: 

* *ftp_server.total_packets*: total packets (sum)
* *ftp_server.concurrent_sessions*: total concurrent FTP sessions (now)
* *ftp_server.max_concurrent_sessions*: maximum concurrent FTP sessions (max)

=== gtp_inspect


What: gtp control channel inspection

Type: inspector

Usage: inspect

Configuration: 

* int *`gtp_inspect[].version`* = 2: GTP version { 0:2 }
* int *`gtp_inspect[].messages[].type`* = 0: message type code { 0:255 }
* string *`gtp_inspect[].messages[].name`*: message name
* int *`gtp_inspect[].infos[].type`* = 0: information element type code { 0:255 }
* string *`gtp_inspect[].infos[].name`*: information element name
* int *`gtp_inspect[].infos[].length`* = 0: information element type code { 0:255 }
* int *gtp_inspect.trace*: mask for enabling debug traces in module { 0:max53 }

Rules: 

* *143:1* (gtp_inspect) message length is invalid
* *143:2* (gtp_inspect) information element length is invalid
* *143:3* (gtp_inspect) information elements are out of order

Peg counts: 

* *gtp_inspect.sessions*: total sessions processed (sum)
* *gtp_inspect.concurrent_sessions*: total concurrent gtp sessions (now)
* *gtp_inspect.max_concurrent_sessions*: maximum concurrent gtp sessions (max)
* *gtp_inspect.events*: requests (sum)
* *gtp_inspect.unknown_types*: unknown message types (sum)
* *gtp_inspect.unknown_infos*: unknown information elements (sum)

=== http2_inspect


What: HTTP/2 inspector

Type: inspector

Usage: inspect

Rules: 


Peg counts: 

* *http2_inspect.flows*: HTTP connections inspected (sum)
* *http2_inspect.concurrent_sessions*: total concurrent HTTP/2 sessions (now)
* *http2_inspect.max_concurrent_sessions*: maximum concurrent HTTP/2 sessions (max)

=== http_inspect


What: HTTP inspector

Type: inspector

Usage: inspect

Configuration: 

* int *http_inspect.request_depth* = -1: maximum request message body bytes to examine (-1 no limit) { -1:max53 }
* int *http_inspect.response_depth* = -1: maximum response message body bytes to examine (-1 no limit) { -1:max53 }
* bool *http_inspect.unzip* = true: decompress gzip and deflate message bodies
* bool *http_inspect.normalize_utf* = true: normalize charset utf encodings in response bodies
* bool *http_inspect.decompress_pdf* = false: decompress pdf files in response bodies
* bool *http_inspect.decompress_swf* = false: decompress swf files in response bodies
* bool *http_inspect.decompress_zip* = false: decompress zip files in response bodies
* bool *http_inspect.normalize_javascript* = false: normalize javascript in response bodies
* int *http_inspect.max_javascript_whitespaces* = 200: maximum consecutive whitespaces allowed within the Javascript obfuscated data { 1:65535 }
* bit_list *http_inspect.bad_characters*: alert when any of specified bytes are present in URI after percent decoding { 255 }
* string *http_inspect.ignore_unreserved*: do not alert when the specified unreserved characters are percent-encoded in a URI.Unreserved characters are 0-9, a-z, A-Z, period, underscore, tilde, and minus. { (optional) }
* bool *http_inspect.percent_u* = false: normalize %uNNNN and %UNNNN encodings
* bool *http_inspect.utf8* = true: normalize 2-byte and 3-byte UTF-8 characters to a single byte
* bool *http_inspect.utf8_bare_byte* = false: when doing UTF-8 character normalization include bytes that were not percent encoded
* bool *http_inspect.iis_unicode* = false: use IIS unicode code point mapping to normalize characters
* string *http_inspect.iis_unicode_map_file*: file containing code points for IIS unicode. { (optional) }
* int *http_inspect.iis_unicode_code_page* = 1252: code page to use from the IIS unicode map file { 0:65535 }
* bool *http_inspect.iis_double_decode* = false: perform double decoding of percent encodings to normalize characters
* int *http_inspect.oversize_dir_length* = 300: maximum length for URL directory { 1:65535 }
* bool *http_inspect.backslash_to_slash* = false: replace \ with / when normalizing URIs
* bool *http_inspect.plus_to_space* = true: replace + with <sp> when normalizing URIs
* bool *http_inspect.simplify_path* = true: reduce URI directory path to simplest form

Rules: 

* *119:1* (http_inspect) ascii encoding
* *119:2* (http_inspect) double decoding attack
* *119:3* (http_inspect) u encoding
* *119:4* (http_inspect) bare byte unicode encoding
* *119:5* (http_inspect) obsolete event--deleted
* *119:6* (http_inspect) UTF-8 encoding
* *119:7* (http_inspect) unicode map code point encoding in URI
* *119:8* (http_inspect) multi_slash encoding
* *119:9* (http_inspect) backslash used in URI path
* *119:10* (http_inspect) self directory traversal
* *119:11* (http_inspect) directory traversal
* *119:12* (http_inspect) apache whitespace (tab)
* *119:13* (http_inspect) HTTP header line terminated by LF without a CR
* *119:14* (http_inspect) non-RFC defined char
* *119:15* (http_inspect) oversize request-uri directory
* *119:16* (http_inspect) oversize chunk encoding
* *119:17* (http_inspect) unauthorized proxy use detected
* *119:18* (http_inspect) webroot directory traversal
* *119:19* (http_inspect) long header
* *119:20* (http_inspect) max header fields
* *119:21* (http_inspect) multiple content length
* *119:22* (http_inspect) obsolete event--deleted
* *119:23* (http_inspect) invalid IP in true-client-IP/XFF header
* *119:24* (http_inspect) multiple host hdrs detected
* *119:25* (http_inspect) hostname exceeds 255 characters
* *119:26* (http_inspect) too much whitespace in header (not implemented yet)
* *119:27* (http_inspect) client consecutive small chunk sizes
* *119:28* (http_inspect) POST or PUT w/o content-length or chunks
* *119:29* (http_inspect) multiple true ips in a session
* *119:30* (http_inspect) both true-client-IP and XFF hdrs present
* *119:31* (http_inspect) unknown method
* *119:32* (http_inspect) simple request
* *119:33* (http_inspect) unescaped space in HTTP URI
* *119:34* (http_inspect) too many pipelined requests
* *119:101* (http_inspect) obsolete event--deleted
* *119:102* (http_inspect) invalid status code in HTTP response
* *119:103* (http_inspect) unused event number--should not appear
* *119:104* (http_inspect) HTTP response has UTF charset that failed to normalize
* *119:105* (http_inspect) HTTP response has UTF-7 charset
* *119:106* (http_inspect) HTTP response gzip decompression failed
* *119:107* (http_inspect) server consecutive small chunk sizes
* *119:108* (http_inspect) unused event number--should not appear
* *119:109* (http_inspect) javascript obfuscation levels exceeds 1
* *119:110* (http_inspect) javascript whitespaces exceeds max allowed
* *119:111* (http_inspect) multiple encodings within javascript obfuscated data
* *119:112* (http_inspect) SWF file zlib decompression failure
* *119:113* (http_inspect) SWF file LZMA decompression failure
* *119:114* (http_inspect) PDF file deflate decompression failure
* *119:115* (http_inspect) PDF file unsupported compression type
* *119:116* (http_inspect) PDF file cascaded compression
* *119:117* (http_inspect) PDF file parse failure
* *119:201* (http_inspect) not HTTP traffic
* *119:202* (http_inspect) chunk length has excessive leading zeros
* *119:203* (http_inspect) white space before or between messages
* *119:204* (http_inspect) request message without URI
* *119:205* (http_inspect) control character in reason phrase
* *119:206* (http_inspect) illegal extra whitespace in start line
* *119:207* (http_inspect) corrupted HTTP version
* *119:208* (http_inspect) unknown HTTP version
* *119:209* (http_inspect) format error in HTTP header
* *119:210* (http_inspect) chunk header options present
* *119:211* (http_inspect) URI badly formatted
* *119:212* (http_inspect) unrecognized type of percent encoding in URI
* *119:213* (http_inspect) HTTP chunk misformatted
* *119:214* (http_inspect) white space adjacent to chunk length
* *119:215* (http_inspect) white space within header name
* *119:216* (http_inspect) excessive gzip compression
* *119:217* (http_inspect) gzip decompression failed
* *119:218* (http_inspect) HTTP 0.9 requested followed by another request
* *119:219* (http_inspect) HTTP 0.9 request following a normal request
* *119:220* (http_inspect) message has both Content-Length and Transfer-Encoding
* *119:221* (http_inspect) status code implying no body combined with Transfer-Encoding or nonzero Content-Length
* *119:222* (http_inspect) Transfer-Encoding not ending with chunked
* *119:223* (http_inspect) Transfer-Encoding with encodings before chunked
* *119:224* (http_inspect) misformatted HTTP traffic
* *119:225* (http_inspect) unsupported Content-Encoding used
* *119:226* (http_inspect) unknown Content-Encoding used
* *119:227* (http_inspect) multiple Content-Encodings applied
* *119:228* (http_inspect) server response before client request
* *119:229* (http_inspect) PDF/SWF/ZIP decompression of server response too big
* *119:230* (http_inspect) nonprinting character in HTTP message header name
* *119:231* (http_inspect) bad Content-Length value in HTTP header
* *119:232* (http_inspect) HTTP header line wrapped
* *119:233* (http_inspect) HTTP header line terminated by CR without a LF
* *119:234* (http_inspect) chunk terminated by nonstandard separator
* *119:235* (http_inspect) chunk length terminated by LF without CR
* *119:236* (http_inspect) more than one response with 100 status code
* *119:237* (http_inspect) 100 status code not in response to Expect header
* *119:238* (http_inspect) 1XX status code other than 100 or 101
* *119:239* (http_inspect) Expect header sent without a message body
* *119:240* (http_inspect) HTTP 1.0 message with Transfer-Encoding header
* *119:241* (http_inspect) Content-Transfer-Encoding used as HTTP header
* *119:242* (http_inspect) illegal field in chunked message trailers
* *119:243* (http_inspect) header field inappropriately appears twice or has two values
* *119:244* (http_inspect) invalid value chunked in Content-Encoding header
* *119:245* (http_inspect) 206 response sent to a request without a Range header
* *119:246* (http_inspect) 'HTTP' in version field not all upper case
* *119:247* (http_inspect) white space embedded in critical header value
* *119:248* (http_inspect) gzip compressed data followed by unexpected non-gzip data

Peg counts: 

* *http_inspect.flows*: HTTP connections inspected (sum)
* *http_inspect.scans*: TCP segments scanned looking for HTTP messages (sum)
* *http_inspect.reassembles*: TCP segments combined into HTTP messages (sum)
* *http_inspect.inspections*: total message sections inspected (sum)
* *http_inspect.requests*: HTTP request messages inspected (sum)
* *http_inspect.responses*: HTTP response messages inspected (sum)
* *http_inspect.get_requests*: GET requests inspected (sum)
* *http_inspect.head_requests*: HEAD requests inspected (sum)
* *http_inspect.post_requests*: POST requests inspected (sum)
* *http_inspect.put_requests*: PUT requests inspected (sum)
* *http_inspect.delete_requests*: DELETE requests inspected (sum)
* *http_inspect.connect_requests*: CONNECT requests inspected (sum)
* *http_inspect.options_requests*: OPTIONS requests inspected (sum)
* *http_inspect.trace_requests*: TRACE requests inspected (sum)
* *http_inspect.other_requests*: other request methods inspected (sum)
* *http_inspect.request_bodies*: POST, PUT, and other requests with message bodies (sum)
* *http_inspect.chunked*: chunked message bodies (sum)
* *http_inspect.uri_normalizations*: URIs needing to be normalization (sum)
* *http_inspect.uri_path*: URIs with path problems (sum)
* *http_inspect.uri_coding*: URIs with character coding problems (sum)
* *http_inspect.concurrent_sessions*: total concurrent http sessions (now)
* *http_inspect.max_concurrent_sessions*: maximum concurrent http sessions (max)

=== imap


What: imap inspection

Type: inspector

Usage: inspect

Configuration: 

* int *imap.b64_decode_depth* = 1460: base64 decoding depth (-1 no limit) { -1:65535 }
* int *imap.bitenc_decode_depth* = 1460: non-Encoded MIME attachment extraction depth (-1 no limit) { -1:65535 }
* bool *imap.decompress_pdf* = false: decompress pdf files in MIME attachments
* bool *imap.decompress_swf* = false: decompress swf files in MIME attachments
* bool *imap.decompress_zip* = false: decompress zip files in MIME attachments
* int *imap.qp_decode_depth* = 1460: quoted Printable decoding depth (-1 no limit) { -1:65535 }
* int *imap.uu_decode_depth* = 1460: Unix-to-Unix decoding depth (-1 no limit) { -1:65535 }

Rules: 

* *141:1* (imap) unknown IMAP3 command
* *141:2* (imap) unknown IMAP3 response
* *141:4* (imap) base64 decoding failed
* *141:5* (imap) quoted-printable decoding failed
* *141:7* (imap) Unix-to-Unix decoding failed
* *141:8* (imap) file decompression failed

Peg counts: 

* *imap.packets*: total packets processed (sum)
* *imap.sessions*: total imap sessions (sum)
* *imap.concurrent_sessions*: total concurrent imap sessions (now)
* *imap.max_concurrent_sessions*: maximum concurrent imap sessions (max)
* *imap.b64_attachments*: total base64 attachments decoded (sum)
* *imap.b64_decoded_bytes*: total base64 decoded bytes (sum)
* *imap.qp_attachments*: total quoted-printable attachments decoded (sum)
* *imap.qp_decoded_bytes*: total quoted-printable decoded bytes (sum)
* *imap.uu_attachments*: total uu attachments decoded (sum)
* *imap.uu_decoded_bytes*: total uu decoded bytes (sum)
* *imap.non_encoded_attachments*: total non-encoded attachments extracted (sum)
* *imap.non_encoded_bytes*: total non-encoded extracted bytes (sum)

=== modbus


What: modbus inspection

Type: inspector

Usage: inspect

Rules: 

* *144:1* (modbus) length in Modbus MBAP header does not match the length needed for the given function
* *144:2* (modbus) Modbus protocol ID is non-zero
* *144:3* (modbus) reserved Modbus function code in use

Peg counts: 

* *modbus.sessions*: total sessions processed (sum)
* *modbus.frames*: total Modbus messages (sum)
* *modbus.concurrent_sessions*: total concurrent modbus sessions (now)
* *modbus.max_concurrent_sessions*: maximum concurrent modbus sessions (max)

=== normalizer


What: packet scrubbing for inline mode

Type: inspector

Usage: inspect

Configuration: 

* bool *normalizer.ip4.base* = true: clear options
* bool *normalizer.ip4.df* = false: clear don't frag flag
* bool *normalizer.ip4.rf* = false: clear reserved flag
* bool *normalizer.ip4.tos* = false: clear tos / differentiated services byte
* bool *normalizer.ip4.trim* = false: truncate excess payload beyond datagram length
* bool *normalizer.tcp.base* = true: clear reserved bits and option padding and fix urgent pointer / flags issues
* bool *normalizer.tcp.block* = true: allow packet drops during TCP normalization
* bool *normalizer.tcp.urp* = true: adjust urgent pointer if beyond segment length
* bool *normalizer.tcp.ips* = false: ensure consistency in retransmitted data
* select *normalizer.tcp.ecn* = off: clear ecn for all packets | sessions w/o ecn setup { off | packet | stream }
* bool *normalizer.tcp.pad* = true: clear any option padding bytes
* bool *normalizer.tcp.trim_syn* = false: remove data on SYN
* bool *normalizer.tcp.trim_rst* = false: remove any data from RST packet
* bool *normalizer.tcp.trim_win* = false: trim data to window
* bool *normalizer.tcp.trim_mss* = false: trim data to MSS
* bool *normalizer.tcp.trim* = false: enable all of the TCP trim options
* bool *normalizer.tcp.opts* = true: clear all options except mss, wscale, timestamp, and any explicitly allowed
* bool *normalizer.tcp.req_urg* = true: clear the urgent pointer if the urgent flag is not set
* bool *normalizer.tcp.req_pay* = true: clear the urgent pointer and the urgent flag if there is no payload
* bool *normalizer.tcp.rsv* = true: clear the reserved bits in the TCP header
* bool *normalizer.tcp.req_urp* = true: clear the urgent flag if the urgent pointer is not set
* multi *normalizer.tcp.allow_names*: don't clear given option names { sack | echo | partial_order | conn_count | alt_checksum | md5 }
* string *normalizer.tcp.allow_codes*: don't clear given option codes
* bool *normalizer.ip6* = false: clear reserved flag
* bool *normalizer.icmp4* = false: clear reserved flag
* bool *normalizer.icmp6* = false: clear reserved flag

Peg counts: 

* *normalizer.test_ip4_trim*: test eth packets trimmed to datagram size (sum)
* *normalizer.ip4_trim*: eth packets trimmed to datagram size (sum)
* *normalizer.test_ip4_tos*: test type of service normalizations (sum)
* *normalizer.ip4_tos*: type of service normalizations (sum)
* *normalizer.test_ip4_df*: test don't frag bit normalizations (sum)
* *normalizer.ip4_df*: don't frag bit normalizations (sum)
* *normalizer.test_ip4_rf*: test reserved flag bit clears (sum)
* *normalizer.ip4_rf*: reserved flag bit clears (sum)
* *normalizer.test_ip4_ttl*: test time-to-live normalizations (sum)
* *normalizer.ip4_ttl*: time-to-live normalizations (sum)
* *normalizer.test_ip4_opts*: test ip4 options cleared (sum)
* *normalizer.ip4_opts*: ip4 options cleared (sum)
* *normalizer.test_icmp4_echo*: test icmp4 ping normalizations (sum)
* *normalizer.icmp4_echo*: icmp4 ping normalizations (sum)
* *normalizer.test_ip6_hops*: test ip6 hop limit normalizations (sum)
* *normalizer.ip6_hops*: ip6 hop limit normalizations (sum)
* *normalizer.test_ip6_options*: test ip6 options cleared (sum)
* *normalizer.ip6_options*: ip6 options cleared (sum)
* *normalizer.test_icmp6_echo*: test icmp6 echo normalizations (sum)
* *normalizer.icmp6_echo*: icmp6 echo normalizations (sum)
* *normalizer.test_tcp_syn_options*: test SYN only options cleared from non-SYN packets (sum)
* *normalizer.tcp_syn_options*: SYN only options cleared from non-SYN packets (sum)
* *normalizer.test_tcp_options*: test packets with options cleared (sum)
* *normalizer.tcp_options*: packets with options cleared (sum)
* *normalizer.test_tcp_padding*: test packets with padding cleared (sum)
* *normalizer.tcp_padding*: packets with padding cleared (sum)
* *normalizer.test_tcp_reserved*: test packets with reserved bits cleared (sum)
* *normalizer.tcp_reserved*: packets with reserved bits cleared (sum)
* *normalizer.test_tcp_nonce*: test packets with nonce bit cleared (sum)
* *normalizer.tcp_nonce*: packets with nonce bit cleared (sum)
* *normalizer.test_tcp_urgent_ptr*: test packets without data with urgent pointer cleared (sum)
* *normalizer.tcp_urgent_ptr*: packets without data with urgent pointer cleared (sum)
* *normalizer.test_tcp_ecn_pkt*: test packets with ECN bits cleared (sum)
* *normalizer.tcp_ecn_pkt*: packets with ECN bits cleared (sum)
* *normalizer.test_tcp_ts_ecr*: test timestamp cleared on non-ACKs (sum)
* *normalizer.tcp_ts_ecr*: timestamp cleared on non-ACKs (sum)
* *normalizer.test_tcp_req_urg*: test cleared urgent pointer when urgent flag is not set (sum)
* *normalizer.tcp_req_urg*: cleared urgent pointer when urgent flag is not set (sum)
* *normalizer.test_tcp_req_pay*: test cleared urgent pointer and urgent flag when there is no payload (sum)
* *normalizer.tcp_req_pay*: cleared urgent pointer and urgent flag when there is no payload (sum)
* *normalizer.test_tcp_req_urp*: test cleared the urgent flag if the urgent pointer is not set (sum)
* *normalizer.tcp_req_urp*: cleared the urgent flag if the urgent pointer is not set (sum)
* *normalizer.test_tcp_trim_syn*: test tcp segments trimmed on SYN (sum)
* *normalizer.tcp_trim_syn*: tcp segments trimmed on SYN (sum)
* *normalizer.test_tcp_trim_rst*: test RST packets with data trimmed (sum)
* *normalizer.tcp_trim_rst*: RST packets with data trimmed (sum)
* *normalizer.test_tcp_trim_win*: test data trimmed to window (sum)
* *normalizer.tcp_trim_win*: data trimmed to window (sum)
* *normalizer.test_tcp_trim_mss*: test data trimmed to MSS (sum)
* *normalizer.tcp_trim_mss*: data trimmed to MSS (sum)
* *normalizer.test_tcp_ecn_session*: test ECN bits cleared (sum)
* *normalizer.tcp_ecn_session*: ECN bits cleared (sum)
* *normalizer.test_tcp_ts_nop*: test timestamp options cleared (sum)
* *normalizer.tcp_ts_nop*: timestamp options cleared (sum)
* *normalizer.test_tcp_ips_data*: test normalized segments (sum)
* *normalizer.tcp_ips_data*: normalized segments (sum)
* *normalizer.test_tcp_block*: test blocked segments (sum)
* *normalizer.tcp_block*: blocked segments (sum)

=== packet_capture


What: raw packet dumping facility

Type: inspector

Usage: global

Configuration: 

* bool *packet_capture.enable* = false: initially enable packet dumping
* string *packet_capture.filter*: bpf filter to use for packet dump

Commands: 

* *packet_capture.enable*(filter): dump raw packets
* *packet_capture.disable*(): stop packet dump

Peg counts: 

* *packet_capture.processed*: packets processed against filter (sum)
* *packet_capture.captured*: packets matching dumped after matching filter (sum)

=== perf_monitor


What: performance monitoring and flow statistics collection

Type: inspector

Usage: global

Configuration: 

* bool *perf_monitor.base* = true: enable base statistics
* bool *perf_monitor.cpu* = false: enable cpu statistics
* bool *perf_monitor.flow* = false: enable traffic statistics
* bool *perf_monitor.flow_ip* = false: enable statistics on host pairs
* int *perf_monitor.packets* = 10000: minimum packets to report { 0:max32 }
* int *perf_monitor.seconds* = 60: report interval { 1:max32 }
* int *perf_monitor.flow_ip_memcap* = 52428800: maximum memory in bytes for flow tracking { 8200:maxSZ }
* int *perf_monitor.max_file_size* = 1073741824: files will be rolled over if they exceed this size { 4096:max53 }
* int *perf_monitor.flow_ports* = 1023: maximum ports to track { 0:65535 }
* enum *perf_monitor.output* = file: output location for stats { file | console }
* string *`perf_monitor.modules[].name`*: name of the module
* string *`perf_monitor.modules[].pegs`*: list of statistics to track or empty for all counters
* enum *perf_monitor.format* = csv: output format for stats { csv | text | json }
* bool *perf_monitor.summary* = false: output summary at shutdown

Peg counts: 

* *perf_monitor.packets*: total packets (sum)

=== pop


What: pop inspection

Type: inspector

Usage: inspect

Configuration: 

* int *pop.b64_decode_depth* = 1460: base64 decoding depth (-1 no limit) { -1:65535 }
* int *pop.bitenc_decode_depth* = 1460: Non-Encoded MIME attachment extraction depth (-1 no limit) { -1:65535 }
* bool *pop.decompress_pdf* = false: decompress pdf files in MIME attachments
* bool *pop.decompress_swf* = false: decompress swf files in MIME attachments
* bool *pop.decompress_zip* = false: decompress zip files in MIME attachments
* int *pop.qp_decode_depth* = 1460: Quoted Printable decoding depth (-1 no limit) { -1:65535 }
* int *pop.uu_decode_depth* = 1460: Unix-to-Unix decoding depth (-1 no limit) { -1:65535 }

Rules: 

* *142:1* (pop) unknown POP3 command
* *142:2* (pop) unknown POP3 response
* *142:4* (pop) base64 decoding failed
* *142:5* (pop) quoted-printable decoding failed
* *142:7* (pop) Unix-to-Unix decoding failed
* *142:8* (pop) file decompression failed

Peg counts: 

* *pop.packets*: total packets processed (sum)
* *pop.sessions*: total pop sessions (sum)
* *pop.concurrent_sessions*: total concurrent pop sessions (now)
* *pop.max_concurrent_sessions*: maximum concurrent pop sessions (max)
* *pop.b64_attachments*: total base64 attachments decoded (sum)
* *pop.b64_decoded_bytes*: total base64 decoded bytes (sum)
* *pop.qp_attachments*: total quoted-printable attachments decoded (sum)
* *pop.qp_decoded_bytes*: total quoted-printable decoded bytes (sum)
* *pop.uu_attachments*: total uu attachments decoded (sum)
* *pop.uu_decoded_bytes*: total uu decoded bytes (sum)
* *pop.non_encoded_attachments*: total non-encoded attachments extracted (sum)
* *pop.non_encoded_bytes*: total non-encoded extracted bytes (sum)

=== port_scan


What: detect various ip, icmp, tcp, and udp port or protocol scans

Type: inspector

Usage: global

Configuration: 

* int *port_scan.memcap* = 1048576: maximum tracker memory in bytes { 1:maxSZ }
* multi *port_scan.protos* = all: choose the protocols to monitor { tcp | udp | icmp | ip | all }
* multi *port_scan.scan_types* = all: choose type of scans to look for { portscan | portsweep | decoy_portscan | distributed_portscan | all }
* string *port_scan.watch_ip*: list of CIDRs with optional ports to watch
* string *port_scan.ignore_scanners*: list of CIDRs with optional ports to ignore if the source of scan alerts
* string *port_scan.ignore_scanned*: list of CIDRs with optional ports to ignore if the destination of scan alerts
* bool *port_scan.alert_all* = false: alert on all events over threshold within window if true; else alert on first only
* bool *port_scan.include_midstream* = false: list of CIDRs with optional ports
* int *port_scan.tcp_ports.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_ports.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_ports.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_ports.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_decoy.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_decoy.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_decoy.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_decoy.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_dist.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_dist.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_dist.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_dist.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_ports.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_ports.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_ports.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_ports.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_decoy.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_decoy.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_decoy.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_decoy.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_dist.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_dist.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_dist.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_dist.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_proto.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_proto.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_proto.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_proto.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_decoy.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_decoy.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_decoy.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_decoy.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_dist.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_dist.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_dist.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_dist.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.icmp_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.icmp_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.icmp_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.icmp_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_window* = 0: detection interval for all TCP scans { 0:max32 }
* int *port_scan.udp_window* = 0: detection interval for all UDP scans { 0:max32 }
* int *port_scan.ip_window* = 0: detection interval for all IP scans { 0:max32 }
* int *port_scan.icmp_window* = 0: detection interval for all ICMP scans { 0:max32 }

Rules: 

* *122:1* (port_scan) TCP portscan
* *122:2* (port_scan) TCP decoy portscan
* *122:3* (port_scan) TCP portsweep
* *122:4* (port_scan) TCP distributed portscan
* *122:5* (port_scan) TCP filtered portscan
* *122:6* (port_scan) TCP filtered decoy portscan
* *122:7* (port_scan) TCP filtered portsweep
* *122:8* (port_scan) TCP filtered distributed portscan
* *122:9* (port_scan) IP protocol scan
* *122:10* (port_scan) IP decoy protocol scan
* *122:11* (port_scan) IP protocol sweep
* *122:12* (port_scan) IP distributed protocol scan
* *122:13* (port_scan) IP filtered protocol scan
* *122:14* (port_scan) IP filtered decoy protocol scan
* *122:15* (port_scan) IP filtered protocol sweep
* *122:16* (port_scan) IP filtered distributed protocol scan
* *122:17* (port_scan) UDP portscan
* *122:18* (port_scan) UDP decoy portscan
* *122:19* (port_scan) UDP portsweep
* *122:20* (port_scan) UDP distributed portscan
* *122:21* (port_scan) UDP filtered portscan
* *122:22* (port_scan) UDP filtered decoy portscan
* *122:23* (port_scan) UDP filtered portsweep
* *122:24* (port_scan) UDP filtered distributed portscan
* *122:25* (port_scan) ICMP sweep
* *122:26* (port_scan) ICMP filtered sweep
* *122:27* (port_scan) open port

Peg counts: 

* *port_scan.packets*: total packets (sum)

=== reputation


What: reputation inspection

Type: inspector

Usage: global

Configuration: 

* string *reputation.blacklist*: blacklist file name with IP lists
* string *reputation.list_dir*: directory for IP lists and manifest file
* int *reputation.memcap* = 500: maximum total MB of memory allocated { 1:4095 }
* enum *reputation.nested_ip* = inner: IP to use when there is IP encapsulation { inner|outer|all }
* enum *reputation.priority* = whitelist: defines priority when there is a decision conflict during run-time { blacklist|whitelist }
* bool *reputation.scan_local* = false: inspect local address defined in RFC 1918
* enum *reputation.white* = unblack: specify the meaning of whitelist { unblack|trust }
* string *reputation.whitelist*: whitelist file name with IP lists

Rules: 

* *136:1* (reputation) packets blacklisted
* *136:2* (reputation) packets whitelisted
* *136:3* (reputation) packets monitored

Peg counts: 

* *reputation.packets*: total packets processed (sum)
* *reputation.blacklisted*: number of packets blacklisted (sum)
* *reputation.whitelisted*: number of packets whitelisted (sum)
* *reputation.monitored*: number of packets monitored (sum)
* *reputation.memory_allocated*: total memory allocated (sum)

=== rpc_decode


What: RPC inspector

Type: inspector

Usage: inspect

Rules: 

* *106:1* (rpc_decode) fragmented RPC records
* *106:2* (rpc_decode) multiple RPC records
* *106:3* (rpc_decode) large RPC record fragment
* *106:4* (rpc_decode) incomplete RPC segment
* *106:5* (rpc_decode) zero-length RPC fragment

Peg counts: 

* *rpc_decode.total_packets*: total packets (sum)
* *rpc_decode.concurrent_sessions*: total concurrent rpc sessions (now)
* *rpc_decode.max_concurrent_sessions*: maximum concurrent rpc sessions (max)

=== sip


What: sip inspection

Type: inspector

Usage: inspect

Configuration: 

* bool *sip.ignore_call_channel* = false: enables the support for ignoring audio/video data channel
* int *sip.max_call_id_len* = 256: maximum call id field size { 0:65535 }
* int *sip.max_contact_len* = 256: maximum contact field size { 0:65535 }
* int *sip.max_content_len* = 1024: maximum content length of the message body { 0:65535 }
* int *sip.max_dialogs* = 4: maximum number of dialogs within one stream session { 1:max32 }
* int *sip.max_from_len* = 256: maximum from field size { 0:65535 }
* int *sip.max_requestName_len* = 20: maximum request name field size { 0:65535 }
* int *sip.max_to_len* = 256: maximum to field size { 0:65535 }
* int *sip.max_uri_len* = 256: maximum request uri field size { 0:65535 }
* int *sip.max_via_len* = 1024: maximum via field size { 0:65535 }
* string *sip.methods* = invite cancel ack  bye register options: list of methods to check in SIP messages

Rules: 

* *140:2* (sip) empty request URI
* *140:3* (sip) URI is too long
* *140:4* (sip) empty call-Id
* *140:5* (sip) Call-Id is too long
* *140:6* (sip) CSeq number is too large or negative
* *140:7* (sip) request name in CSeq is too long
* *140:8* (sip) empty From header
* *140:9* (sip) From header is too long
* *140:10* (sip) empty To header
* *140:11* (sip) To header is too long
* *140:12* (sip) empty Via header
* *140:13* (sip) Via header is too long
* *140:14* (sip) empty Contact
* *140:15* (sip) contact is too long
* *140:16* (sip) content length is too large or negative
* *140:17* (sip) multiple SIP messages in a packet
* *140:18* (sip) content length mismatch
* *140:19* (sip) request name is invalid
* *140:20* (sip) Invite replay attack
* *140:21* (sip) illegal session information modification
* *140:22* (sip) response status code is not a 3 digit number
* *140:23* (sip) empty Content-type header
* *140:24* (sip) SIP version is invalid
* *140:25* (sip) mismatch in METHOD of request and the CSEQ header
* *140:26* (sip) method is unknown
* *140:27* (sip) maximum dialogs within a session reached

Peg counts: 

* *sip.packets*: total packets (sum)
* *sip.sessions*: total sessions (sum)
* *sip.concurrent_sessions*: total concurrent SIP sessions (now)
* *sip.max_concurrent_sessions*: maximum concurrent SIP sessions (max)
* *sip.events*: events generated (sum)
* *sip.dialogs*: total dialogs (sum)
* *sip.ignored_channels*: total channels ignored (sum)
* *sip.ignored_sessions*: total sessions ignored (sum)
* *sip.total_requests*: total requests (sum)
* *sip.invite*: invite (sum)
* *sip.cancel*: cancel (sum)
* *sip.ack*: ack (sum)
* *sip.bye*: bye (sum)
* *sip.register*: register (sum)
* *sip.options*: options (sum)
* *sip.refer*: refer (sum)
* *sip.subscribe*: subscribe (sum)
* *sip.update*: update (sum)
* *sip.join*: join (sum)
* *sip.info*: info (sum)
* *sip.message*: message (sum)
* *sip.notify*: notify (sum)
* *sip.prack*: prack (sum)
* *sip.total_responses*: total responses (sum)
* *sip.code_1xx*: 1xx (sum)
* *sip.code_2xx*: 2xx (sum)
* *sip.code_3xx*: 3xx (sum)
* *sip.code_4xx*: 4xx (sum)
* *sip.code_5xx*: 5xx (sum)
* *sip.code_6xx*: 6xx (sum)
* *sip.code_7xx*: 7xx (sum)
* *sip.code_8xx*: 8xx (sum)
* *sip.code_9xx*: 9xx (sum)

=== smtp


What: smtp inspection

Type: inspector

Usage: inspect

Configuration: 

* string *`smtp.alt_max_command_line_len[].command`*: command string
* int *`smtp.alt_max_command_line_len[].length`* = 0: specify non-default maximum for command { 0:max32 }
* string *smtp.auth_cmds*: commands that initiate an authentication exchange
* int *smtp.b64_decode_depth* = 1460: depth used to decode the base64 encoded MIME attachments (-1 no limit) { -1:65535 }
* string *smtp.binary_data_cmds*: commands that initiate sending of data and use a length value after the command
* int *smtp.bitenc_decode_depth* = 1460: depth used to extract the non-encoded MIME attachments (-1 no limit) { -1:65535 }
* string *smtp.data_cmds*: commands that initiate sending of data with an end of data delimiter
* bool *smtp.decompress_pdf* = false: decompress pdf files in MIME attachments
* bool *smtp.decompress_swf* = false: decompress swf files in MIME attachments
* bool *smtp.decompress_zip* = false: decompress zip files in MIME attachments
* int *smtp.email_hdrs_log_depth* = 1464: depth for logging email headers { 0:20480 }
* bool *smtp.ignore_data* = false: ignore data section of mail
* bool *smtp.ignore_tls_data* = false: ignore TLS-encrypted data when processing rules
* string *smtp.invalid_cmds*: alert if this command is sent from client side
* bool *smtp.log_email_hdrs* = false: log the SMTP email headers extracted from SMTP data
* bool *smtp.log_filename* = false: log the MIME attachment filenames extracted from the Content-Disposition header within the MIME body
* bool *smtp.log_mailfrom* = false: log the sender's email address extracted from the MAIL FROM command
* bool *smtp.log_rcptto* = false: log the recipient's email address extracted from the RCPT TO command
* int *smtp.max_auth_command_line_len* = 1000: max auth command Line Length { 0:65535 }
* int *smtp.max_command_line_len* = 0: max Command Line Length { 0:65535 }
* int *smtp.max_header_line_len* = 0: max SMTP DATA header line { 0:65535 }
* int *smtp.max_response_line_len* = 0: max SMTP response line { 0:65535 }
* enum *smtp.normalize* = none: turns on/off normalization { none | cmds | all }
* string *smtp.normalize_cmds*: list of commands to normalize
* int *smtp.qp_decode_depth* = 1460: quoted-Printable decoding depth (-1 no limit) { -1:65535 }
* int *smtp.uu_decode_depth* = 1460: Unix-to-Unix decoding depth (-1 no limit) { -1:65535 }
* string *smtp.valid_cmds*: list of valid commands
* enum *smtp.xlink2state* = alert: enable/disable xlink2state alert { disable | alert | drop }

Rules: 

* *124:1* (smtp) attempted command buffer overflow
* *124:2* (smtp) attempted data header buffer overflow
* *124:3* (smtp) attempted response buffer overflow
* *124:4* (smtp) attempted specific command buffer overflow
* *124:5* (smtp) unknown command
* *124:6* (smtp) illegal command
* *124:7* (smtp) attempted header name buffer overflow
* *124:8* (smtp) attempted X-Link2State command buffer overflow
* *124:10* (smtp) base64 decoding failed
* *124:11* (smtp) quoted-printable decoding failed
* *124:13* (smtp) Unix-to-Unix decoding failed
* *124:14* (smtp) Cyrus SASL authentication attack
* *124:15* (smtp) attempted authentication command buffer overflow
* *124:16* (smtp) file decompression failed

Peg counts: 

* *smtp.packets*: total packets processed (sum)
* *smtp.sessions*: total smtp sessions (sum)
* *smtp.concurrent_sessions*: total concurrent smtp sessions (now)
* *smtp.max_concurrent_sessions*: maximum concurrent smtp sessions (max)
* *smtp.b64_attachments*: total base64 attachments decoded (sum)
* *smtp.b64_decoded_bytes*: total base64 decoded bytes (sum)
* *smtp.qp_attachments*: total quoted-printable attachments decoded (sum)
* *smtp.qp_decoded_bytes*: total quoted-printable decoded bytes (sum)
* *smtp.uu_attachments*: total uu attachments decoded (sum)
* *smtp.uu_decoded_bytes*: total uu decoded bytes (sum)
* *smtp.non_encoded_attachments*: total non-encoded attachments extracted (sum)
* *smtp.non_encoded_bytes*: total non-encoded extracted bytes (sum)

=== ssh


What: ssh inspection

Type: inspector

Usage: inspect

Configuration: 

* int *ssh.max_encrypted_packets* = 25: ignore session after this many encrypted packets { 0:65535 }
* int *ssh.max_client_bytes* = 19600: number of unanswered bytes before alerting on challenge-response overflow or CRC32 { 0:65535 }
* int *ssh.max_server_version_len* = 80: limit before alerting on secure CRT server version string overflow { 0:255 }

Rules: 

* *128:1* (ssh) challenge-response overflow exploit
* *128:2* (ssh) SSH1 CRC32 exploit
* *128:3* (ssh) server version string overflow
* *128:5* (ssh) bad message direction
* *128:6* (ssh) payload size incorrect for the given payload
* *128:7* (ssh) failed to detect SSH version string

Peg counts: 

* *ssh.packets*: total packets (sum)
* *ssh.concurrent_sessions*: total concurrent ssh sessions (now)
* *ssh.max_concurrent_sessions*: maximum concurrent ssh sessions (max)

=== ssl


What: ssl inspection

Type: inspector

Usage: inspect

Configuration: 

* bool *ssl.trust_servers* = false: disables requirement that application (encrypted) data must be observed on both sides
* int *ssl.max_heartbeat_length* = 0: maximum length of heartbeat record allowed { 0:65535 }

Rules: 

* *137:1* (ssl) invalid client HELLO after server HELLO detected
* *137:2* (ssl) invalid server HELLO without client HELLO detected
* *137:3* (ssl) heartbeat read overrun attempt detected
* *137:4* (ssl) large heartbeat response detected

Peg counts: 

* *ssl.packets*: total packets processed (sum)
* *ssl.decoded*: ssl packets decoded (sum)
* *ssl.client_hello*: total client hellos (sum)
* *ssl.server_hello*: total server hellos (sum)
* *ssl.certificate*: total ssl certificates (sum)
* *ssl.server_done*: total server done (sum)
* *ssl.client_key_exchange*: total client key exchanges (sum)
* *ssl.server_key_exchange*: total server key exchanges (sum)
* *ssl.change_cipher*: total change cipher records (sum)
* *ssl.finished*: total handshakes finished (sum)
* *ssl.client_application*: total client application records (sum)
* *ssl.server_application*: total server application records (sum)
* *ssl.alert*: total ssl alert records (sum)
* *ssl.unrecognized_records*: total unrecognized records (sum)
* *ssl.handshakes_completed*: total completed ssl handshakes (sum)
* *ssl.bad_handshakes*: total bad handshakes (sum)
* *ssl.sessions_ignored*: total sessions ignore (sum)
* *ssl.detection_disabled*: total detection disabled (sum)
* *ssl.concurrent_sessions*: total concurrent ssl sessions (now)
* *ssl.max_concurrent_sessions*: maximum concurrent ssl sessions (max)

=== stream


What: common flow tracking

Type: inspector

Usage: global

Configuration: 

* int *stream.footprint* = 0: use zero for production, non-zero for testing at given size (for TCP and user) { 0:max32 }
* bool *stream.ip_frags_only* = false: don't process non-frag flows
* int *stream.ip_cache.max_sessions* = 16384: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.ip_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream.ip_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.ip_cache.cap_weight* = 64: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.icmp_cache.max_sessions* = 65536: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.icmp_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream.icmp_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.icmp_cache.cap_weight* = 8: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.tcp_cache.max_sessions* = 262144: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.tcp_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream.tcp_cache.idle_timeout* = 3600: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.tcp_cache.cap_weight* = 11500: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.udp_cache.max_sessions* = 131072: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.udp_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream.udp_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.udp_cache.cap_weight* = 128: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.user_cache.max_sessions* = 1024: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.user_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream.user_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.user_cache.cap_weight* = 256: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.file_cache.max_sessions* = 128: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.file_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream.file_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.file_cache.cap_weight* = 32: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.trace*: mask for enabling debug traces in module { 0:max53 }

Rules: 

* *135:1* (stream) TCP SYN received
* *135:2* (stream) TCP session established
* *135:3* (stream) TCP session cleared

Peg counts: 

* *stream.ip_flows*: total ip sessions (sum)
* *stream.ip_total_prunes*: total ip sessions pruned (sum)
* *stream.ip_idle_prunes*: ip sessions pruned due to timeout (sum)
* *stream.ip_excess_prunes*: ip sessions pruned due to excess (sum)
* *stream.ip_uni_prunes*: ip uni sessions pruned (sum)
* *stream.ip_preemptive_prunes*: ip sessions pruned during preemptive pruning (sum)
* *stream.ip_memcap_prunes*: ip sessions pruned due to memcap (sum)
* *stream.ip_ha_prunes*: ip sessions pruned by high availability sync (sum)
* *stream.icmp_flows*: total icmp sessions (sum)
* *stream.icmp_total_prunes*: total icmp sessions pruned (sum)
* *stream.icmp_idle_prunes*: icmp sessions pruned due to timeout (sum)
* *stream.icmp_excess_prunes*: icmp sessions pruned due to excess (sum)
* *stream.icmp_uni_prunes*: icmp uni sessions pruned (sum)
* *stream.icmp_preemptive_prunes*: icmp sessions pruned during preemptive pruning (sum)
* *stream.icmp_memcap_prunes*: icmp sessions pruned due to memcap (sum)
* *stream.icmp_ha_prunes*: icmp sessions pruned by high availability sync (sum)
* *stream.tcp_flows*: total tcp sessions (sum)
* *stream.tcp_total_prunes*: total tcp sessions pruned (sum)
* *stream.tcp_idle_prunes*: tcp sessions pruned due to timeout (sum)
* *stream.tcp_excess_prunes*: tcp sessions pruned due to excess (sum)
* *stream.tcp_uni_prunes*: tcp uni sessions pruned (sum)
* *stream.tcp_preemptive_prunes*: tcp sessions pruned during preemptive pruning (sum)
* *stream.tcp_memcap_prunes*: tcp sessions pruned due to memcap (sum)
* *stream.tcp_ha_prunes*: tcp sessions pruned by high availability sync (sum)
* *stream.udp_flows*: total udp sessions (sum)
* *stream.udp_total_prunes*: total udp sessions pruned (sum)
* *stream.udp_idle_prunes*: udp sessions pruned due to timeout (sum)
* *stream.udp_excess_prunes*: udp sessions pruned due to excess (sum)
* *stream.udp_uni_prunes*: udp uni sessions pruned (sum)
* *stream.udp_preemptive_prunes*: udp sessions pruned during preemptive pruning (sum)
* *stream.udp_memcap_prunes*: udp sessions pruned due to memcap (sum)
* *stream.udp_ha_prunes*: udp sessions pruned by high availability sync (sum)
* *stream.user_flows*: total user sessions (sum)
* *stream.user_total_prunes*: total user sessions pruned (sum)
* *stream.user_idle_prunes*: user sessions pruned due to timeout (sum)
* *stream.user_excess_prunes*: user sessions pruned due to excess (sum)
* *stream.user_uni_prunes*: user uni sessions pruned (sum)
* *stream.user_preemptive_prunes*: user sessions pruned during preemptive pruning (sum)
* *stream.user_memcap_prunes*: user sessions pruned due to memcap (sum)
* *stream.user_ha_prunes*: user sessions pruned by high availability sync (sum)
* *stream.file_flows*: total file sessions (sum)
* *stream.file_total_prunes*: total file sessions pruned (sum)
* *stream.file_idle_prunes*: file sessions pruned due to timeout (sum)
* *stream.file_excess_prunes*: file sessions pruned due to excess (sum)
* *stream.file_uni_prunes*: file uni sessions pruned (sum)
* *stream.file_preemptive_prunes*: file sessions pruned during preemptive pruning (sum)
* *stream.file_memcap_prunes*: file sessions pruned due to memcap (sum)
* *stream.file_ha_prunes*: file sessions pruned by high availability sync (sum)

=== stream_file


What: stream inspector for file flow tracking and processing

Type: inspector

Usage: inspect

Configuration: 

* bool *stream_file.upload* = false: indicate file transfer direction

=== stream_icmp


What: stream inspector for ICMP flow tracking

Type: inspector

Usage: inspect

Configuration: 

* int *stream_icmp.session_timeout* = 30: session tracking timeout { 1:max31 }

Peg counts: 

* *stream_icmp.sessions*: total icmp sessions (sum)
* *stream_icmp.max*: max icmp sessions (max)
* *stream_icmp.created*: icmp session trackers created (sum)
* *stream_icmp.released*: icmp session trackers released (sum)
* *stream_icmp.timeouts*: icmp session timeouts (sum)
* *stream_icmp.prunes*: icmp session prunes (sum)

=== stream_ip


What: stream inspector for IP flow tracking and defragmentation

Type: inspector

Usage: inspect

Configuration: 

* int *stream_ip.max_frags* = 8192: maximum number of simultaneous fragments being tracked { 1:max32 }
* int *stream_ip.max_overlaps* = 0: maximum allowed overlaps per datagram; 0 is unlimited { 0:max32 }
* int *stream_ip.min_frag_length* = 0: alert if fragment length is below this limit before or after trimming { 0:65535 }
* int *stream_ip.min_ttl* = 1: discard fragments with TTL below the minimum { 1:255 }
* enum *stream_ip.policy* = linux: fragment reassembly policy { first | linux | bsd | bsd_right | last | windows | solaris }
* int *stream_ip.session_timeout* = 30: session tracking timeout { 1:max31 }
* int *stream_ip.trace*: mask for enabling debug traces in module { 0:max53 }

Rules: 

* *123:1* (stream_ip) inconsistent IP options on fragmented packets
* *123:2* (stream_ip) teardrop attack
* *123:3* (stream_ip) short fragment, possible DOS attempt
* *123:4* (stream_ip) fragment packet ends after defragmented packet
* *123:5* (stream_ip) zero-byte fragment packet
* *123:6* (stream_ip) bad fragment size, packet size is negative
* *123:7* (stream_ip) bad fragment size, packet size is greater than 65536
* *123:8* (stream_ip) fragmentation overlap
* *123:11* (stream_ip) TTL value less than configured minimum, not using for reassembly
* *123:12* (stream_ip) excessive fragment overlap
* *123:13* (stream_ip) tiny fragment

Peg counts: 

* *stream_ip.sessions*: total ip sessions (sum)
* *stream_ip.max*: max ip sessions (max)
* *stream_ip.created*: ip session trackers created (sum)
* *stream_ip.released*: ip session trackers released (sum)
* *stream_ip.timeouts*: ip session timeouts (sum)
* *stream_ip.prunes*: ip session prunes (sum)
* *stream_ip.total_frags*: total fragments (sum)
* *stream_ip.current_frags*: current fragments (now)
* *stream_ip.max_frags*: max fragments (sum)
* *stream_ip.reassembled*: reassembled datagrams (sum)
* *stream_ip.discards*: fragments discarded (sum)
* *stream_ip.frag_timeouts*: datagrams abandoned (sum)
* *stream_ip.overlaps*: overlapping fragments (sum)
* *stream_ip.anomalies*: anomalies detected (sum)
* *stream_ip.alerts*: alerts generated (sum)
* *stream_ip.drops*: fragments dropped (sum)
* *stream_ip.trackers_added*: datagram trackers created (sum)
* *stream_ip.trackers_freed*: datagram trackers released (sum)
* *stream_ip.trackers_cleared*: datagram trackers cleared (sum)
* *stream_ip.trackers_completed*: datagram trackers completed (sum)
* *stream_ip.nodes_inserted*: fragments added to tracker (sum)
* *stream_ip.nodes_deleted*: fragments deleted from tracker (sum)
* *stream_ip.reassembled_bytes*: total reassembled bytes (sum)
* *stream_ip.fragmented_bytes*: total fragmented bytes (sum)

=== stream_tcp


What: stream inspector for TCP flow tracking and stream normalization and reassembly

Type: inspector

Usage: inspect

Configuration: 

* int *stream_tcp.flush_factor* = 0: flush upon seeing a drop in segment size after given number of non-decreasing segments { 0:65535 }
* int *stream_tcp.max_window* = 0: maximum allowed TCP window { 0:1073725440 }
* int *stream_tcp.overlap_limit* = 0: maximum number of allowed overlapping segments per session { 0:max32 }
* int *stream_tcp.max_pdu* = 16384: maximum reassembled PDU size { 1460:32768 }
* enum *stream_tcp.policy* = bsd: determines operating system characteristics like reassembly { first | last | linux | old_linux | bsd | macos | solaris | irix | hpux11 | hpux10 | windows | win_2003 | vista | proxy }
* bool *stream_tcp.reassemble_async* = true: queue data for reassembly before traffic is seen in both directions
* int *stream_tcp.require_3whs* = -1: don't track midstream sessions after given seconds from start up; -1 tracks all { -1:max31 }
* bool *stream_tcp.show_rebuilt_packets* = false: enable cmg like output of reassembled packets
* int *stream_tcp.queue_limit.max_bytes* = 1048576: don't queue more than given bytes per session and direction { 0:max32 }
* int *stream_tcp.queue_limit.max_segments* = 2621: don't queue more than given segments per session and direction { 0:max32 }
* int *stream_tcp.small_segments.count* = 0: limit number of small segments queued { 0:2048 }
* int *stream_tcp.small_segments.maximum_size* = 0: limit number of small segments queued { 0:2048 }
* int *stream_tcp.session_timeout* = 30: session tracking timeout { 1:max31 }
* bool *stream_tcp.track_only* = false: disable reassembly if true

Rules: 

* *129:1* (stream_tcp) SYN on established session
* *129:2* (stream_tcp) data on SYN packet
* *129:3* (stream_tcp) data sent on stream not accepting data
* *129:4* (stream_tcp) TCP timestamp is outside of PAWS window
* *129:5* (stream_tcp) bad segment, adjusted size <= 0 (deprecated)
* *129:6* (stream_tcp) window size (after scaling) larger than policy allows
* *129:7* (stream_tcp) limit on number of overlapping TCP packets reached
* *129:8* (stream_tcp) data sent on stream after TCP reset sent
* *129:9* (stream_tcp) TCP client possibly hijacked, different ethernet address
* *129:10* (stream_tcp) TCP server possibly hijacked, different ethernet address
* *129:11* (stream_tcp) TCP data with no TCP flags set
* *129:12* (stream_tcp) consecutive TCP small segments exceeding threshold
* *129:13* (stream_tcp) 4-way handshake detected
* *129:14* (stream_tcp) TCP timestamp is missing
* *129:15* (stream_tcp) reset outside window
* *129:16* (stream_tcp) FIN number is greater than prior FIN
* *129:17* (stream_tcp) ACK number is greater than prior FIN
* *129:18* (stream_tcp) data sent on stream after TCP reset received
* *129:19* (stream_tcp) TCP window closed before receiving data
* *129:20* (stream_tcp) TCP session without 3-way handshake

Peg counts: 

* *stream_tcp.sessions*: total tcp sessions (sum)
* *stream_tcp.max*: max tcp sessions (max)
* *stream_tcp.created*: tcp session trackers created (sum)
* *stream_tcp.released*: tcp session trackers released (sum)
* *stream_tcp.timeouts*: tcp session timeouts (sum)
* *stream_tcp.prunes*: tcp session prunes (sum)
* *stream_tcp.instantiated*: new sessions instantiated (sum)
* *stream_tcp.setups*: session initializations (sum)
* *stream_tcp.restarts*: sessions restarted (sum)
* *stream_tcp.resyns*: SYN received on established session (sum)
* *stream_tcp.discards*: tcp packets discarded (sum)
* *stream_tcp.events*: events generated (sum)
* *stream_tcp.ignored*: tcp packets ignored (sum)
* *stream_tcp.untracked*: tcp packets not tracked (sum)
* *stream_tcp.syn_trackers*: tcp session tracking started on syn (sum)
* *stream_tcp.syn_ack_trackers*: tcp session tracking started on syn-ack (sum)
* *stream_tcp.three_way_trackers*: tcp session tracking started on ack (sum)
* *stream_tcp.data_trackers*: tcp session tracking started on data (sum)
* *stream_tcp.segs_queued*: total segments queued (sum)
* *stream_tcp.segs_released*: total segments released (sum)
* *stream_tcp.segs_split*: tcp segments split when reassembling PDUs (sum)
* *stream_tcp.segs_used*: queued tcp segments applied to reassembled PDUs (sum)
* *stream_tcp.rebuilt_packets*: total reassembled PDUs (sum)
* *stream_tcp.rebuilt_buffers*: rebuilt PDU sections (sum)
* *stream_tcp.rebuilt_bytes*: total rebuilt bytes (sum)
* *stream_tcp.overlaps*: overlapping segments queued (sum)
* *stream_tcp.gaps*: missing data between PDUs (sum)
* *stream_tcp.exceeded_max_segs*: number of times the maximum queued segment limit was reached (sum)
* *stream_tcp.exceeded_max_bytes*: number of times the maximum queued byte limit was reached (sum)
* *stream_tcp.internal_events*: 135:X events generated (sum)
* *stream_tcp.client_cleanups*: number of times data from server was flushed when session released (sum)
* *stream_tcp.server_cleanups*: number of times data from client was flushed when session released (sum)
* *stream_tcp.memory*: current memory in use (now)
* *stream_tcp.initializing*: number of sessions currently initializing (now)
* *stream_tcp.established*: number of sessions currently established (now)
* *stream_tcp.closing*: number of sessions currently closing (now)
* *stream_tcp.syns*: number of syn packets (sum)
* *stream_tcp.syn_acks*: number of syn-ack packets (sum)
* *stream_tcp.resets*: number of reset packets (sum)
* *stream_tcp.fins*: number of fin packets (sum)

=== stream_udp


What: stream inspector for UDP flow tracking

Type: inspector

Usage: inspect

Configuration: 

* int *stream_udp.session_timeout* = 30: session tracking timeout { 1:max31 }

Peg counts: 

* *stream_udp.sessions*: total udp sessions (sum)
* *stream_udp.max*: max udp sessions (max)
* *stream_udp.created*: udp session trackers created (sum)
* *stream_udp.released*: udp session trackers released (sum)
* *stream_udp.timeouts*: udp session timeouts (sum)
* *stream_udp.prunes*: udp session prunes (sum)
* *stream_udp.ignored*: udp packets ignored (sum)

=== stream_user


What: stream inspector for user flow tracking and reassembly 

Type: inspector

Usage: inspect

Configuration: 

* int *stream_user.session_timeout* = 30: session tracking timeout { 1:max31 }
* int *stream_user.trace*: mask for enabling debug traces in module { 0:max53 }

=== telnet


What: telnet inspection and normalization

Type: inspector

Usage: inspect

Configuration: 

* int *telnet.ayt_attack_thresh* = -1: alert on this number of consecutive Telnet AYT commands { -1:max31 }
* bool *telnet.check_encrypted* = false: check for end of encryption
* bool *telnet.encrypted_traffic* = false: check for encrypted Telnet and FTP
* bool *telnet.normalize* = false: eliminate escape sequences

Rules: 

* *126:1* (telnet) consecutive Telnet AYT commands beyond threshold
* *126:2* (telnet) Telnet traffic encrypted
* *126:3* (telnet) Telnet subnegotiation begin command without subnegotiation end

Peg counts: 

* *telnet.total_packets*: total packets (sum)
* *telnet.concurrent_sessions*: total concurrent Telnet sessions (now)
* *telnet.max_concurrent_sessions*: maximum concurrent Telnet sessions (max)

=== wizard


What: inspector that implements port-independent protocol identification

Type: inspector

Usage: inspect

Configuration: 

* string *`wizard.hexes[].service`*: name of service
* select *`wizard.hexes[].proto`* = tcp: protocol to scan { tcp | udp }
* bool *`wizard.hexes[].client_first`* = true: which end initiates data transfer
* string *`wizard.hexes[].to_server[].hex`*: sequence of data with wild chars (?)
* string *`wizard.hexes[].to_client[].hex`*: sequence of data with wild chars (?)
* string *`wizard.spells[].service`*: name of service
* select *`wizard.spells[].proto`* = tcp: protocol to scan { tcp | udp }
* bool *`wizard.spells[].client_first`* = true: which end initiates data transfer
* string *`wizard.spells[].to_server[].spell`*: sequence of data with wild cards (*)
* string *`wizard.spells[].to_client[].spell`*: sequence of data with wild cards (*)
* multi *wizard.curses*: enable service identification based on internal algorithm { dce_smb | dce_udp | dce_tcp }

Peg counts: 

* *wizard.tcp_scans*: tcp payload scans (sum)
* *wizard.tcp_hits*: tcp identifications (sum)
* *wizard.udp_scans*: udp payload scans (sum)
* *wizard.udp_hits*: udp identifications (sum)
* *wizard.user_scans*: user payload scans (sum)
* *wizard.user_hits*: user identifications (sum)
