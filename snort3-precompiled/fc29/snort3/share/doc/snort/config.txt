* interval *ack.~range*: check if TCP ack value is 'value | min<>max | <max | >min' { 0: }
* int *active.attempts* = 0: number of TCP packets sent per response (with varying sequence numbers) { 0:255 }
* string *active.device*: use 'ip' for network layer responses or 'eth0' etc for link layer
* string *active.dst_mac*: use format '01:23:45:67:89:ab'
* int *active.max_responses* = 0: maximum number of responses { 0:255 }
* int *active.min_interval* = 255: minimum number of seconds between responses { 1:255 }
* multi *alert_csv.fields* = timestamp pkt_num proto pkt_gen pkt_len dir src_ap dst_ap rule action: selected fields will be output in given order left to right { action | class | b64_data | dir | dst_addr | dst_ap | dst_port | eth_dst | eth_len | eth_src | eth_type | gid | icmp_code | icmp_id | icmp_seq | icmp_type | iface | ip_id | ip_len | msg | mpls | pkt_gen | pkt_len | pkt_num | priority | proto | rev | rule | seconds | service | sid | src_addr | src_ap | src_port | target | tcp_ack | tcp_flags | tcp_len | tcp_seq | tcp_win | timestamp | tos | ttl | udp_len | vlan }
* bool *alert_csv.file* = false: output to alert_csv.txt instead of stdout
* int *alert_csv.limit* = 0: set maximum size in MB before rollover (0 is unlimited) { 0:maxSZ }
* string *alert_csv.separator* = , : separate fields with this character sequence
* bool *alert_fast.file* = false: output to alert_fast.txt instead of stdout
* int *alert_fast.limit* = 0: set maximum size in MB before rollover (0 is unlimited) { 0:maxSZ }
* bool *alert_fast.packet* = false: output packet dump with alert
* bool *alert_full.file* = false: output to alert_full.txt instead of stdout
* int *alert_full.limit* = 0: set maximum size in MB before rollover (0 is unlimited) { 0:maxSZ }
* multi *alert_json.fields* = timestamp pkt_num proto pkt_gen pkt_len dir src_ap dst_ap rule action: selected fields will be output in given order left to right { action | class | b64_data | dir | dst_addr | dst_ap | dst_port | eth_dst | eth_len | eth_src | eth_type | gid | icmp_code | icmp_id | icmp_seq | icmp_type | iface | ip_id | ip_len | msg | mpls | pkt_gen | pkt_len | pkt_num | priority | proto | rev | rule | seconds | service | sid | src_addr | src_ap | src_port | target | tcp_ack | tcp_flags | tcp_len | tcp_seq | tcp_win | timestamp | tos | ttl | udp_len | vlan }
* bool *alert_json.file* = false: output to alert_json.txt instead of stdout
* int *alert_json.limit* = 0: set maximum size in MB before rollover (0 is unlimited) { 0:maxSZ }
* string *alert_json.separator* = , : separate fields with this character sequence
* bool *alerts.alert_with_interface_name* = false: include interface in alert info (fast, full, or syslog only)
* int *alerts.detection_filter_memcap* = 1048576: set available MB of memory for detection_filters { 0:max32 }
* int *alerts.event_filter_memcap* = 1048576: set available MB of memory for event_filters { 0:max32 }
* string *alert_sfsocket.file*: name of unix socket file
* int *`alert_sfsocket.rules[].gid`* = 1: rule generator ID { 1:max32 }
* int *`alert_sfsocket.rules[].sid`* = 1: rule signature ID { 1:max32 }
* bool *alerts.log_references* = false: include rule references in alert info (full only)
* string *alerts.order* = pass drop alert log: change the order of rule action application
* int *alerts.rate_filter_memcap* = 1048576: set available MB of memory for rate_filters { 0:max32 }
* string *alerts.reference_net*: set the CIDR for homenet (for use with -l or -B, does NOT change $HOME_NET in IDS mode)
* bool *alerts.stateful* = false: don't alert w/o established session (note: rule action still taken)
* string *alerts.tunnel_verdicts*: let DAQ handle non-allow verdicts for gtp|teredo|6in4|4in6|4in4|6in6|gre|mpls traffic
* enum *alert_syslog.facility* = auth: part of priority applied to each message { auth | authpriv | daemon | user | local0 | local1 | local2 | local3 | local4 | local5 | local6 | local7 }
* enum *alert_syslog.level* = info: part of priority applied to each message { emerg | alert | crit | err | warning | notice | info | debug }
* multi *alert_syslog.options*: used to open the syslog connection { cons | ndelay | perror | pid }
* string *appid.app_detector_dir*: directory to load appid detectors from
* int *appid.app_stats_period* = 300: time period for collecting and logging appid statistics { 1:max32 }
* int *appid.app_stats_rollover_size* = 20971520: max file size for appid stats before rolling over the log file { 0:max32 }
* int *appid.app_stats_rollover_time* = 86400: max time period for collection appid stats before rolling over the log file { 0:max31 }
* bool *appid.debug* = false: enable appid debug logging
* bool *appid.dump_ports* = false: enable dump of appid port information
* int *appid.instance_id* = 0: instance id - ignored { 0:max32 }
* bool *appid.log_all_sessions* = false: enable logging of all appid sessions
* bool *appid.log_stats* = false: enable logging of appid statistics
* int *appid.memcap* = 1048576: max size of the service cache before we start pruning the cache { 1024:maxSZ }
* string *appids.~*: comma separated list of application names
* bool *appid.tp_appid_config_dump*: print third party configuration on startup
* string *appid.tp_appid_config*: path to third party appid configuration file
* string *appid.tp_appid_path*: path to third party appid dynamic library
* bool *appid.tp_appid_stats_enable*: enable collection of stats and print stats on exit in third party module
* int *appid.trace*: mask for enabling debug traces in module { 0:max53 }
* ip4 *`arp_spoof.hosts[].ip`*: host ip address
* mac *`arp_spoof.hosts[].mac`*: host mac address
* int *asn1.absolute_offset*: absolute offset from the beginning of the packet { 0:65535 }
* implied *asn1.bitstring_overflow*: detects invalid bitstring encodings that are known to be remotely exploitable
* implied *asn1.double_overflow*: detects a double ASCII encoding that is larger than a standard buffer
* int *asn1.oversize_length*: compares ASN.1 type lengths with the supplied argument { 0:max32 }
* implied *asn1.print*: dump decode data to console; always true
* int *asn1.relative_offset*: relative offset from the cursor { -65535:65535 }
* int *attribute_table.max_hosts* = 1024: maximum number of hosts in attribute table { 32:max53 }
* int *attribute_table.max_metadata_services* = 8: maximum number of services in rule { 1:255 }
* int *attribute_table.max_services_per_host* = 8: maximum number of services per host entry in attribute table { 1:65535 }
* int *base64_decode.bytes*: number of base64 encoded bytes to decode { 1:max32 }
* int *base64_decode.offset* = 0: bytes past start of buffer to start decoding { 0:max32 }
* implied *base64_decode.relative*: apply offset to cursor instead of start of buffer
* enum *`binder[].use.action`* = inspect: what to do with matching traffic { reset | block | allow | inspect }
* string *`binder[].use.file`*: use configuration in given file
* string *`binder[].use.inspection_policy`*: use inspection policy from given file
* string *`binder[].use.ips_policy`*: use ips policy from given file
* string *`binder[].use.name`*: symbol name (defaults to type)
* string *`binder[].use.network_policy`*: use network policy from given file
* string *`binder[].use.service`*: override automatic service identification
* string *`binder[].use.type`*: select module for binding
* addr_list *`binder[].when.dst_nets`*: list of destination networks
* bit_list *`binder[].when.dst_ports`*: list of destination ports { 65535 }
* bit_list *`binder[].when.dst_zone`*: destination zone { 63 }
* bit_list *`binder[].when.ifaces`*: list of interface indices { 255 }
* int *`binder[].when.ips_policy_id`* = 0: unique ID for selection of this config by external logic { 0:max32 }
* addr_list *`binder[].when.nets`*: list of networks
* bit_list *`binder[].when.ports`*: list of ports { 65535 }
* enum *`binder[].when.proto`*: protocol { any | ip | icmp | tcp | udp | user | file }
* enum *`binder[].when.role`* = any: use the given configuration on one or any end of a session { client | server | any }
* string *`binder[].when.service`*: override default configuration
* addr_list *`binder[].when.src_nets`*: list of source networks
* bit_list *`binder[].when.src_ports`*: list of source ports { 65535 }
* bit_list *`binder[].when.src_zone`*: source zone { 63 }
* bit_list *`binder[].when.vlans`*: list of VLAN IDs { 4095 }
* bit_list *`binder[].when.zones`*: zones { 63 }
* interval *bufferlen.~range*: check that length of current buffer is in given range { 0:65535 }
* int *byte_extract.align* = 0: round the number of converted bytes up to the next 2- or 4-byte boundary { 0:4 }
* implied *byte_extract.big*: big endian
* int *byte_extract.bitmask*: applies as an AND to the extracted value before storage in 'name' { 0x1:0xFFFFFFFF }
* int *byte_extract.~count*: number of bytes to pick up from the buffer { 1:10 }
* implied *byte_extract.dce*: dcerpc2 determines endianness
* implied *byte_extract.dec*: convert from decimal string
* implied *byte_extract.hex*: convert from hex string
* implied *byte_extract.little*: little endian
* int *byte_extract.multiplier* = 1: scale extracted value by given amount { 1:65535 }
* string *byte_extract.~name*: name of the variable that will be used in other rule options
* implied *byte_extract.oct*: convert from octal string
* int *byte_extract.~offset*: number of bytes into the buffer to start processing { -65535:65535 }
* implied *byte_extract.relative*: offset from cursor instead of start of buffer
* implied *byte_extract.string*: convert from string
* int *byte_jump.align* = 0: round the number of converted bytes up to the next 2- or 4-byte boundary { 0:4 }
* implied *byte_jump.big*: big endian
* int *byte_jump.bitmask*: applies as an AND prior to evaluation { 0x1:0xFFFFFFFF }
* int *byte_jump.~count*: number of bytes to pick up from the buffer { 0:10 }
* implied *byte_jump.dce*: dcerpc2 determines endianness
* implied *byte_jump.dec*: convert from decimal string
* implied *byte_jump.from_beginning*: jump from start of buffer instead of cursor
* implied *byte_jump.from_end*: jump backward from end of buffer
* implied *byte_jump.hex*: convert from hex string
* implied *byte_jump.little*: little endian
* int *byte_jump.multiplier* = 1: scale extracted value by given amount { 1:65535 }
* implied *byte_jump.oct*: convert from octal string
* string *byte_jump.~offset*: variable name or number of bytes into the buffer to start processing
* string *byte_jump.post_offset*: skip forward or backward (positive or negative value) by variable name or number of bytes after the other jump options have been applied
* implied *byte_jump.relative*: offset from cursor instead of start of buffer
* implied *byte_jump.string*: convert from string
* int *byte_math.bitmask*: applies as bitwise AND to the extracted value before storage in 'name' { 0x1:0xFFFFFFFF }
* int *byte_math.bytes*: number of bytes to pick up from the buffer { 1:10 }
* implied *byte_math.dce*: dcerpc2 determines endianness
* enum *byte_math.endian*: specify big/little endian { big|little }
* string *byte_math.offset*: number of bytes into the buffer to start processing
* enum *byte_math.oper*: mathematical operation to perform { +|-|*|/|<<|>> }
* implied *byte_math.relative*: offset from cursor instead of start of buffer
* string *byte_math.result*: name of the variable to store the result
* string *byte_math.rvalue*: value to use mathematical operation against
* enum *byte_math.string*: convert extracted string to dec/hex/oct { hex|dec|oct }
* implied *byte_test.big*: big endian
* int *byte_test.bitmask*: applies as an AND prior to evaluation { 0x1:0xFFFFFFFF }
* string *byte_test.~compare*: variable name or value to test the converted result against
* int *byte_test.~count*: number of bytes to pick up from the buffer { 1:10 }
* implied *byte_test.dce*: dcerpc2 determines endianness
* implied *byte_test.dec*: convert from decimal string
* implied *byte_test.hex*: convert from hex string
* implied *byte_test.little*: little endian
* implied *byte_test.oct*: convert from octal string
* string *byte_test.~offset*: variable name or number of bytes into the payload to start processing
* string *byte_test.~operator*: operation to perform to test the value
* implied *byte_test.relative*: offset from cursor instead of start of buffer
* implied *byte_test.string*: convert from string
* string *`classifications[].name`*: name used with classtype rule option
* int *`classifications[].priority`* = 1: default priority for class { 0:max32 }
* string *`classifications[].text`*: description of class
* string *classtype.~*: classification for this rule
* string *content.~data*: data to match
* string *content.depth*: var or maximum number of bytes to search from beginning of buffer
* string *content.distance*: var or number of bytes from cursor to start search
* int *content.fast_pattern_length*: maximum number of characters from this content the fast pattern matcher should use { 1:65535 }
* int *content.fast_pattern_offset* = 0: number of leading characters of this content the fast pattern matcher should exclude { 0:65535 }
* implied *content.fast_pattern*: use this content in the fast pattern matcher instead of the content selected by default
* implied *content.nocase*: case insensitive match
* string *content.offset*: var or number of bytes from start of buffer to start search
* string *content.within*: var or maximum number of bytes to search from cursor
* implied *cvs.invalid-entry*: looks for an invalid Entry string
* string *daq.input_spec*: input specification
* int *`daq.instances[].id`*: instance ID (required) { 0:max32 }
* string *`daq.instances[].input_spec`*: input specification
* string *`daq.instances[].variables[].str`*: string parameter
* string *daq.module*: DAQ module to use
* string *`daq.module_dirs[].str`*: string parameter
* bool *daq.no_promisc* = false: whether to put DAQ device into promiscuous mode
* int *daq.snaplen*: set snap length (same as -s) { 0:65535 }
* string *`daq.variables[].str`*: string parameter
* implied *dce_iface.any_frag*: match on any fragment
* string *dce_iface.uuid*: match given dcerpc uuid
* interval *dce_iface.version*: interface version { 0: }
* string *dce_opnum.~*: match given dcerpc operation number, range or list
* bool *dce_smb.disable_defrag* = false: disable DCE/RPC defragmentation
* bool *dce_smb.limit_alerts* = true: limit DCE alert to at most one per signature per flow
* int *dce_smb.max_frag_len* = 65535: maximum fragment size for defragmentation { 1514:65535 }
* enum *dce_smb.policy* = WinXP: target based policy to use { Win2000 |  WinXP | WinVista | Win2003 | Win2008 | Win7 | Samba | Samba-3.0.37 | Samba-3.0.22 | Samba-3.0.20 }
* int *dce_smb.reassemble_threshold* = 0: minimum bytes received before performing reassembly { 0:65535 }
* int *dce_smb.smb_file_depth* = 16384: SMB file depth for file data { -1:32767 }
* enum *dce_smb.smb_file_inspection* = off: SMB file inspection { off | on | only }
* enum *dce_smb.smb_fingerprint_policy* = none: target based SMB policy to use { none | client |  server | both  }
* string *dce_smb.smb_invalid_shares*: SMB shares to alert on 
* bool *dce_smb.smb_legacy_mode* = false: inspect only SMBv1
* int *dce_smb.smb_max_chain* = 3: SMB max chain size { 0:255 }
* int *dce_smb.smb_max_compound* = 3: SMB max compound size { 0:255 }
* int *dce_smb.trace*: mask for enabling debug traces in module { 0:max53 }
* multi *dce_smb.valid_smb_versions* = all: valid SMB versions { v1 | v2 | all }
* bool *dce_tcp.disable_defrag* = false: disable DCE/RPC defragmentation
* bool *dce_tcp.limit_alerts* = true: limit DCE alert to at most one per signature per flow
* int *dce_tcp.max_frag_len* = 65535: maximum fragment size for defragmentation { 1514:65535 }
* enum *dce_tcp.policy* = WinXP: target based policy to use { Win2000 |  WinXP | WinVista | Win2003 | Win2008 | Win7 | Samba | Samba-3.0.37 | Samba-3.0.22 | Samba-3.0.20 }
* int *dce_tcp.reassemble_threshold* = 0: minimum bytes received before performing reassembly { 0:65535 }
* bool *dce_udp.disable_defrag* = false: disable DCE/RPC defragmentation
* bool *dce_udp.limit_alerts* = true: limit DCE alert to at most one per signature per flow
* int *dce_udp.max_frag_len* = 65535: maximum fragment size for defragmentation { 1514:65535 }
* int *dce_udp.trace*: mask for enabling debug traces in module { 0:max53 }
* int *decode.trace*: mask for enabling debug traces in module { 0:max53 }
* int *detection.asn1* = 0: maximum decode nodes { 0:65535 }
* bool *detection.enable_address_anomaly_checks* = false: enable check and alerting of address anomalies
* int *detection_filter.count*: hits in interval before allowing the rule to fire { 1:max32 }
* int *detection_filter.seconds*: length of interval to count hits { 1:max32 }
* enum *detection_filter.track*: track hits by source or destination IP address { by_src | by_dst }
* bool *detection.global_default_rule_state* = true: enable or disable rules by default (overridden by ips policy settings)
* bool *detection.global_rule_state* = false: apply rule_state against all policies
* int *detection.offload_limit* = 99999: minimum sizeof PDU to offload fast pattern search (defaults to disabled) { 0:max32 }
* int *detection.offload_threads* = 0: maximum number of simultaneous offloads (defaults to disabled) { 0:max32 }
* bool *detection.pcre_enable* = true: disable pcre pattern matching
* int *detection.pcre_match_limit* = 1500: limit pcre backtracking, 0 = off { 0:max32 }
* int *detection.pcre_match_limit_recursion* = 1500: limit pcre stack consumption, 0 = off { 0:max32 }
* int *detection.trace*: mask for enabling debug traces in module { 0:max53 }
* bool *dnp3.check_crc* = false: validate checksums in DNP3 link layer frames
* string *dnp3_func.~*: match DNP3 function code or name
* string *dnp3_ind.~*: match given DNP3 indicator flags
* int *dnp3_obj.group* = 0: match given DNP3 object header group { 0:255 }
* int *dnp3_obj.var* = 0: match given DNP3 object header var { 0:255 }
* interval *dsize.~range*: check if packet payload size is in the given range { 0:65535 }
* bool *esp.decode_esp* = false: enable for inspection of esp traffic that has authentication but not encryption
* int *`event_filter[].count`* = 0: number of events in interval before tripping; -1 to disable { -1:max31 }
* int *`event_filter[].gid`* = 1: rule generator ID { 0:max32 }
* string *`event_filter[].ip`*: restrict filter to these addresses according to track
* int *`event_filter[].seconds`* = 0: count interval { 0:max32 }
* int *`event_filter[].sid`* = 1: rule signature ID { 0:max32 }
* enum *`event_filter[].track`*: filter only matching source or destination addresses { by_src | by_dst }
* enum *`event_filter[].type`*: 1st count events | every count events | once after count events { limit | threshold | both }
* int *event_queue.log* = 3: maximum events to log { 1:max32 }
* int *event_queue.max_queue* = 8: maximum events to queue { 1:max32 }
* enum *event_queue.order_events* = content_length: criteria for ordering incoming events { priority|content_length }
* bool *event_queue.process_all_events* = false: process just first action group or all action groups
* string *file_connector.connector*: connector name
* enum *file_connector.direction*: usage { receive | transmit | duplex }
* enum *file_connector.format*: file format { binary | text }
* string *file_connector.name*: channel name
* int *file_id.block_timeout* = 86400: stop blocking after this many seconds { 0:max31 }
* bool *file_id.block_timeout_lookup* = false: block if lookup times out
* int *file_id.capture_block_size* = 32768: file capture block size in bytes { 8:max53 }
* int *file_id.capture_max_size* = 1048576: stop file capture beyond this point { 0:max53 }
* int *file_id.capture_memcap* = 100: memcap for file capture in megabytes { 0:max53 }
* int *file_id.capture_min_size* = 0: stop file capture if file size less than this { 0:max53 }
* bool *file_id.enable_capture* = false: enable file capture
* bool *file_id.enable_signature* = true: enable signature calculation
* bool *file_id.enable_type* = true: enable type ID
* bool *`file_id.file_policy[].use.enable_file_capture`* = false: true/false -> enable/disable file capture
* bool *`file_id.file_policy[].use.enable_file_signature`* = false: true/false -> enable/disable file signature
* bool *`file_id.file_policy[].use.enable_file_type`* = false: true/false -> enable/disable file type identification
* enum *`file_id.file_policy[].use.verdict`* = unknown: what to do with matching traffic { unknown | log | stop | block | reset  }
* int *`file_id.file_policy[].when.file_type_id`* = 0: unique ID for file type in file magic rule { 0:max32 }
* string *`file_id.file_policy[].when.sha256`*: SHA 256
* string *`file_id.file_rules[].category`*: file type category
* string *`file_id.file_rules[].group`*: comma separated list of groups associated with file type
* int *`file_id.file_rules[].id`* = 0: file type id { 0:max32 }
* string *`file_id.file_rules[].magic[].content`*: file magic content
* int *`file_id.file_rules[].magic[].offset`* = 0: file magic offset { 0:max32 }
* string *`file_id.file_rules[].msg`*: information about the file type
* int *`file_id.file_rules[].rev`* = 0: rule revision { 0:max32 }
* string *`file_id.file_rules[].type`*: file type name
* string *`file_id.file_rules[].version`*: file type version
* int *file_id.lookup_timeout* = 2: give up on lookup after this many seconds { 0:max31 }
* int *file_id.max_files_cached* = 65536: maximal number of files cached in memory { 8:max53 }
* int *file_id.show_data_depth* = 100: print this many octets { 0:max53 }
* int *file_id.signature_depth* = 10485760: stop signature at this point { 0:max53 }
* bool *file_id.trace_signature* = false: enable runtime dump of signature info
* bool *file_id.trace_stream* = false: enable runtime dump of file data
* bool *file_id.trace_type* = false: enable runtime dump of type info
* int *file_id.type_depth* = 1460: stop type ID at this point { 0:max53 }
* int *file_id.verdict_delay* = 0: number of queries to return final verdict { 0:max53 }
* bool *file_log.log_pkt_time* = true: log the packet time when event generated
* bool *file_log.log_sys_time* = false: log the system time when event generated
* string *file_type.~*: list of file type IDs to match
* string *flags.~mask_flags*: these flags are don't cares
* string *flags.~test_flags*: these flags are tested
* string *flowbits.~arg1*: bits or group
* string *flowbits.~arg2*: group if arg1 is bits
* string *flowbits.~command*: set|reset|isset|etc.
* implied *flow.established*: match only during data transfer phase
* implied *flow.from_client*: same as to_server
* implied *flow.from_server*: same as to_client
* implied *flow.no_frag*: match on raw packets only
* implied *flow.no_stream*: match on raw packets only
* implied *flow.not_established*: match only outside data transfer phase
* implied *flow.only_frag*: match on defragmented packets only
* implied *flow.only_stream*: match on reassembled packets only
* implied *flow.stateless*: match regardless of stream state
* implied *flow.to_client*: match on server responses
* implied *flow.to_server*: match on client requests
* string *fragbits.~flags*: these flags are tested
* interval *fragoffset.~range*: check if ip fragment offset is in given range { 0:8192 }
* bool *ftp_client.bounce* = false: check for bounces
* addr *`ftp_client.bounce_to[].address`* = 1.0.0.0/32: allowed IP address in CIDR format
* port *`ftp_client.bounce_to[].last_port`*: optional allowed range from port to last_port inclusive
* port *`ftp_client.bounce_to[].port`* = 20: allowed port
* bool *ftp_client.ignore_telnet_erase_cmds* = false: ignore erase character and erase line commands when normalizing
* int *ftp_client.max_resp_len* = 4294967295: maximum FTP response accepted by client { 0:max32 }
* bool *ftp_client.telnet_cmds* = false: detect Telnet escape sequences on FTP control channel
* bool *ftp_server.check_encrypted* = false: check for end of encryption
* string *ftp_server.chk_str_fmt*: check the formatting of the given commands
* string *`ftp_server.cmd_validity[].command`*: command string
* string *`ftp_server.cmd_validity[].format`*: format specification
* int *`ftp_server.cmd_validity[].length`* = 0: specify non-default maximum for command { 0:max32 }
* string *ftp_server.data_chan_cmds*: check the formatting of the given commands
* string *ftp_server.data_rest_cmds*: check the formatting of the given commands
* string *ftp_server.data_xfer_cmds*: check the formatting of the given commands
* int *ftp_server.def_max_param_len* = 100: default maximum length of commands handled by server; 0 is unlimited { 1:max32 }
* string *`ftp_server.directory_cmds[].dir_cmd`*: directory command
* int *`ftp_server.directory_cmds[].rsp_code`* = 200: expected successful response code for command { 200:max32 }
* string *ftp_server.encr_cmds*: check the formatting of the given commands
* bool *ftp_server.encrypted_traffic* = false: check for encrypted Telnet and FTP
* string *ftp_server.file_get_cmds*: check the formatting of the given commands
* string *ftp_server.file_put_cmds*: check the formatting of the given commands
* string *ftp_server.ftp_cmds*: specify additional commands supported by server beyond RFC 959
* bool *ftp_server.ignore_data_chan* = false: do not inspect FTP data channels
* bool *ftp_server.ignore_telnet_erase_cmds* = false: ignore erase character and erase line commands when normalizing
* string *ftp_server.login_cmds*: check the formatting of the given commands
* bool *ftp_server.print_cmds* = false: print command configurations on start up
* bool *ftp_server.telnet_cmds* = false: detect Telnet escape sequences of FTP control channel
* int *gid.~*: generator id { 1:max32 }
* string *gtp_info.~*: info element to match
* int *`gtp_inspect[].infos[].length`* = 0: information element type code { 0:255 }
* string *`gtp_inspect[].infos[].name`*: information element name
* int *`gtp_inspect[].infos[].type`* = 0: information element type code { 0:255 }
* string *`gtp_inspect[].messages[].name`*: message name
* int *`gtp_inspect[].messages[].type`* = 0: message type code { 0:255 }
* int *gtp_inspect.trace*: mask for enabling debug traces in module { 0:max53 }
* int *`gtp_inspect[].version`* = 2: GTP version { 0:2 }
* string *gtp_type.~*: list of types to match
* int *gtp_version.~*: version to match { 0:2 }
* bool *high_availability.daq_channel* = false: enable use of daq data plane channel
* bool *high_availability.enable* = false: enable high availability
* real *high_availability.min_age* = 1.0: minimum session life before HA updates { 0.0:100.0 }
* real *high_availability.min_sync* = 1.0: minimum interval between HA updates { 0.0:100.0 }
* bit_list *high_availability.ports*: side channel message port list { 65535 }
* int *`host_cache[].size`*: size of host cache { 1:max32 }
* enum *`hosts[].frag_policy`*: defragmentation policy { first | linux | bsd | bsd_right | last | windows | solaris }
* addr *`hosts[].ip`* = 0.0.0.0/32: hosts address / CIDR
* string *`hosts[].services[].name`*: service identifier
* port *`hosts[].services[].port`*: port number
* enum *`hosts[].services[].proto`* = tcp: IP protocol { tcp | udp }
* enum *`hosts[].tcp_policy`*: TCP reassembly policy { first | last | linux | old_linux | bsd | macos | solaris | irix | hpux11 | hpux10 | windows | win_2003 | vista | proxy }
* enum *`host_tracker[].frag_policy`*: defragmentation policy { first | linux | bsd | bsd_right | last | windows | solaris }
* addr *`host_tracker[].ip`* = 0.0.0.0/32: hosts address / cidr
* string *`host_tracker[].services[].name`*: service identifier
* port *`host_tracker[].services[].port`*: port number
* enum *`host_tracker[].services[].proto`* = tcp: IP protocol { tcp | udp }
* enum *`host_tracker[].tcp_policy`*: TCP reassembly policy { first | last | linux | old_linux | bsd | macos | solaris | irix | hpux11 | hpux10 | windows | win_2003 | vista | proxy }
* implied *http_cookie.request*: match against the cookie from the request message even when examining the response
* implied *http_cookie.with_body*: parts of this rule examine HTTP message body
* implied *http_cookie.with_trailer*: parts of this rule examine HTTP message trailers
* string *http_header.field*: restrict to given header. Header name is case insensitive.
* implied *http_header.request*: match against the headers from the request message even when examining the response
* implied *http_header.with_body*: parts of this rule examine HTTP message body
* implied *http_header.with_trailer*: parts of this rule examine HTTP message trailers
* bool *http_inspect.backslash_to_slash* = false: replace \ with / when normalizing URIs
* bit_list *http_inspect.bad_characters*: alert when any of specified bytes are present in URI after percent decoding { 255 }
* bool *http_inspect.decompress_pdf* = false: decompress pdf files in response bodies
* bool *http_inspect.decompress_swf* = false: decompress swf files in response bodies
* bool *http_inspect.decompress_zip* = false: decompress zip files in response bodies
* string *http_inspect.ignore_unreserved*: do not alert when the specified unreserved characters are percent-encoded in a URI.Unreserved characters are 0-9, a-z, A-Z, period, underscore, tilde, and minus. { (optional) }
* bool *http_inspect.iis_double_decode* = false: perform double decoding of percent encodings to normalize characters
* int *http_inspect.iis_unicode_code_page* = 1252: code page to use from the IIS unicode map file { 0:65535 }
* bool *http_inspect.iis_unicode* = false: use IIS unicode code point mapping to normalize characters
* string *http_inspect.iis_unicode_map_file*: file containing code points for IIS unicode. { (optional) }
* int *http_inspect.max_javascript_whitespaces* = 200: maximum consecutive whitespaces allowed within the Javascript obfuscated data { 1:65535 }
* bool *http_inspect.normalize_javascript* = false: normalize javascript in response bodies
* bool *http_inspect.normalize_utf* = true: normalize charset utf encodings in response bodies
* int *http_inspect.oversize_dir_length* = 300: maximum length for URL directory { 1:65535 }
* bool *http_inspect.percent_u* = false: normalize %uNNNN and %UNNNN encodings
* bool *http_inspect.plus_to_space* = true: replace + with <sp> when normalizing URIs
* int *http_inspect.request_depth* = -1: maximum request message body bytes to examine (-1 no limit) { -1:max53 }
* int *http_inspect.response_depth* = -1: maximum response message body bytes to examine (-1 no limit) { -1:max53 }
* bool *http_inspect.simplify_path* = true: reduce URI directory path to simplest form
* bool *http_inspect.unzip* = true: decompress gzip and deflate message bodies
* bool *http_inspect.utf8_bare_byte* = false: when doing UTF-8 character normalization include bytes that were not percent encoded
* bool *http_inspect.utf8* = true: normalize 2-byte and 3-byte UTF-8 characters to a single byte
* implied *http_method.with_body*: parts of this rule examine HTTP message body
* implied *http_method.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_raw_cookie.request*: match against the cookie from the request message even when examining the response
* implied *http_raw_cookie.with_body*: parts of this rule examine HTTP message body
* implied *http_raw_cookie.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_raw_header.request*: match against the headers from the request message even when examining the response
* implied *http_raw_header.with_body*: parts of this rule examine HTTP message body
* implied *http_raw_header.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_raw_request.with_body*: parts of this rule examine HTTP message body
* implied *http_raw_request.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_raw_status.with_body*: parts of this rule examine HTTP message body
* implied *http_raw_status.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_raw_trailer.request*: match against the trailers from the request message even when examining the response
* implied *http_raw_trailer.with_body*: parts of this rule examine HTTP response message body (must be combined with request)
* implied *http_raw_trailer.with_header*: parts of this rule examine HTTP response message headers (must be combined with request)
* implied *http_raw_uri.fragment*: match against fragment section of URI only
* implied *http_raw_uri.host*: match against host section of URI only
* implied *http_raw_uri.path*: match against path section of URI only
* implied *http_raw_uri.port*: match against port section of URI only
* implied *http_raw_uri.query*: match against query section of URI only
* implied *http_raw_uri.scheme*: match against scheme section of URI only
* implied *http_raw_uri.with_body*: parts of this rule examine HTTP message body
* implied *http_raw_uri.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_stat_code.with_body*: parts of this rule examine HTTP message body
* implied *http_stat_code.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_stat_msg.with_body*: parts of this rule examine HTTP message body
* implied *http_stat_msg.with_trailer*: parts of this rule examine HTTP message trailers
* string *http_trailer.field*: restrict to given trailer
* implied *http_trailer.request*: match against the trailers from the request message even when examining the response
* implied *http_trailer.with_body*: parts of this rule examine HTTP message body (must be combined with request)
* implied *http_trailer.with_header*: parts of this rule examine HTTP response message headers (must be combined with request)
* implied *http_true_ip.with_body*: parts of this rule examine HTTP message body
* implied *http_true_ip.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_uri.fragment*: match against fragment section of URI only
* implied *http_uri.host*: match against host section of URI only
* implied *http_uri.path*: match against path section of URI only
* implied *http_uri.port*: match against port section of URI only
* implied *http_uri.query*: match against query section of URI only
* implied *http_uri.scheme*: match against scheme section of URI only
* implied *http_uri.with_body*: parts of this rule examine HTTP message body
* implied *http_uri.with_trailer*: parts of this rule examine HTTP message trailers
* implied *http_version.request*: match against the version from the request message even when examining the response
* implied *http_version.with_body*: parts of this rule examine HTTP message body
* implied *http_version.with_trailer*: parts of this rule examine HTTP message trailers
* interval *icmp_id.~range*: check if ICMP ID is in given range { 0:65535 }
* interval *icmp_seq.~range*: check if ICMP sequence number is in given range { 0:65535 }
* interval *icode.~range*: check if ICMP code is in given range is { 0:255 }
* interval *id.~range*: check if the IP ID is in the given range { 0: }
* int *imap.b64_decode_depth* = 1460: base64 decoding depth (-1 no limit) { -1:65535 }
* int *imap.bitenc_decode_depth* = 1460: non-Encoded MIME attachment extraction depth (-1 no limit) { -1:65535 }
* bool *imap.decompress_pdf* = false: decompress pdf files in MIME attachments
* bool *imap.decompress_swf* = false: decompress swf files in MIME attachments
* bool *imap.decompress_zip* = false: decompress zip files in MIME attachments
* int *imap.qp_decode_depth* = 1460: quoted Printable decoding depth (-1 no limit) { -1:65535 }
* int *imap.uu_decode_depth* = 1460: Unix-to-Unix decoding depth (-1 no limit) { -1:65535 }
* int *inspection.id* = 0: correlate policy and events with other items in configuration { 0:65535 }
* enum *inspection.mode* = inline-test: set policy mode { inline | inline-test }
* select *ipopts.~opt*: output format { rr|eol|nop|ts|sec|esec|lsrr|lsrre|ssrr|satid|any }
* string *ip_proto.~proto*: [!|>|<] name or number
* enum *ips.default_rule_state* = inherit: enable or disable ips rules { false | true | inherit }
* bool *ips.enable_builtin_rules* = false: enable events from builtin rules w/o stubs
* int *ips.id* = 0: correlate unified2 events with configuration { 0:65535 }
* string *ips.include*: legacy snort rules and includes
* enum *ips.mode*: set policy mode { tap | inline | inline-test }
* bool *ips.obfuscate_pii* = false: mask all but the last 4 characters of credit card and social security numbers
* string *ips.rules*: snort rules and includes
* string *isdataat.~length*: num | !num
* implied *isdataat.relative*: offset from cursor instead of start of buffer
* interval *itype.~range*: check if ICMP type is in given range { 0:255 }
* enum *latency.packet.action* = none: event action if packet times out and is fastpathed { none | alert | log | alert_and_log }
* bool *latency.packet.fastpath* = false: fastpath expensive packets (max_time exceeded)
* int *latency.packet.max_time* = 500: set timeout for packet latency thresholding (usec) { 0:max53 }
* enum *latency.rule.action* = none: event action for rule latency enable and suspend events { none | alert | log | alert_and_log }
* int *latency.rule.max_suspend_time* = 30000: set max time for suspending a rule (ms, 0 means permanently disable rule) { 0:max32 }
* int *latency.rule.max_time* = 500: set timeout for rule evaluation (usec) { 0:max53 }
* bool *latency.rule.suspend* = false: temporarily suspend expensive rules
* int *latency.rule.suspend_threshold* = 5: set threshold for number of timeouts before suspending a rule { 1:max32 }
* bool *log_codecs.file* = false: output to log_codecs.txt instead of stdout
* bool *log_codecs.msg* = false: include alert msg
* bool *log_hext.file* = false: output to log_hext.txt instead of stdout
* int *log_hext.limit* = 0: set maximum size in MB before rollover (0 is unlimited) { 0:maxSZ }
* bool *log_hext.raw* = false: output all full packets if true, else just TCP payload
* int *log_hext.width* = 20: set line width (0 is unlimited) { 0:max32 }
* int *log_pcap.limit* = 0: set maximum size in MB before rollover (0 is unlimited) { 0:maxSZ }
* string *md5.~hash*: data to match
* int *md5.length*: number of octets in plain text { 1:65535 }
* string *md5.offset*: var or number of bytes from start of buffer to start search
* implied *md5.relative* = false: offset from cursor instead of start of buffer
* int *memory.cap* = 0: set the per-packet-thread cap on memory (bytes, 0 to disable) { 0:maxSZ }
* int *memory.threshold* = 0: set the per-packet-thread threshold for preemptive cleanup actions (percent, 0 to disable) { 0:100 }
* string *`metadata.*`*: comma-separated list of arbitrary name value pairs
* string *modbus_func.~*: function code to match
* int *modbus_unit.~*: Modbus unit ID { 0:255 }
* bool *mpls.enable_mpls_multicast* = false: enables support for MPLS multicast
* bool *mpls.enable_mpls_overlapping_ip* = false: enable if private network addresses overlap and must be differentiated by MPLS label(s)
* int *mpls.max_mpls_stack_depth* = -1: set MPLS stack depth { -1:255 }
* enum *mpls.mpls_payload_type* = ip4: set encapsulated payload type { eth | ip4 | ip6 }
* string *msg.~*: message describing rule
* multi *network.checksum_drop* = none: drop if checksum is bad { all | ip | noip | tcp | notcp | udp | noudp | icmp | noicmp | none }
* multi *network.checksum_eval* = none: checksums to verify { all | ip | noip | tcp | notcp | udp | noudp | icmp | noicmp | none }
* bool *network.decode_drops* = false: enable dropping of packets by the decoder
* int *network.id* = 0: correlate unified2 events with configuration { 0:65535 }
* int *network.layers* = 40: the maximum number of protocols that Snort can correctly decode { 3:255 }
* int *network.max_ip6_extensions* = 0: the maximum number of IP6 options Snort will process for a given IPv6 layer before raising 116:456 (0 = unlimited) { 0:255 }
* int *network.max_ip_layers* = 0: the maximum number of IP layers Snort will process for a given packet before raising 116:293 (0 = unlimited) { 0:255 }
* int *network.min_ttl* = 1: alert / normalize packets with lower TTL / hop limit (you must enable rules and / or normalization also) { 1:255 }
* int *network.new_ttl* = 1: use this value for responses and when normalizing { 1:255 }
* bool *normalizer.icmp4* = false: clear reserved flag
* bool *normalizer.icmp6* = false: clear reserved flag
* bool *normalizer.ip4.base* = true: clear options
* bool *normalizer.ip4.df* = false: clear don't frag flag
* bool *normalizer.ip4.rf* = false: clear reserved flag
* bool *normalizer.ip4.tos* = false: clear tos / differentiated services byte
* bool *normalizer.ip4.trim* = false: truncate excess payload beyond datagram length
* bool *normalizer.ip6* = false: clear reserved flag
* string *normalizer.tcp.allow_codes*: don't clear given option codes
* multi *normalizer.tcp.allow_names*: don't clear given option names { sack | echo | partial_order | conn_count | alt_checksum | md5 }
* bool *normalizer.tcp.base* = true: clear reserved bits and option padding and fix urgent pointer / flags issues
* bool *normalizer.tcp.block* = true: allow packet drops during TCP normalization
* select *normalizer.tcp.ecn* = off: clear ecn for all packets | sessions w/o ecn setup { off | packet | stream }
* bool *normalizer.tcp.ips* = false: ensure consistency in retransmitted data
* bool *normalizer.tcp.opts* = true: clear all options except mss, wscale, timestamp, and any explicitly allowed
* bool *normalizer.tcp.pad* = true: clear any option padding bytes
* bool *normalizer.tcp.req_pay* = true: clear the urgent pointer and the urgent flag if there is no payload
* bool *normalizer.tcp.req_urg* = true: clear the urgent pointer if the urgent flag is not set
* bool *normalizer.tcp.req_urp* = true: clear the urgent flag if the urgent pointer is not set
* bool *normalizer.tcp.rsv* = true: clear the reserved bits in the TCP header
* bool *normalizer.tcp.trim* = false: enable all of the TCP trim options
* bool *normalizer.tcp.trim_mss* = false: trim data to MSS
* bool *normalizer.tcp.trim_rst* = false: remove any data from RST packet
* bool *normalizer.tcp.trim_syn* = false: remove data on SYN
* bool *normalizer.tcp.trim_win* = false: trim data to window
* bool *normalizer.tcp.urp* = true: adjust urgent pointer if beyond segment length
* bool *output.dump_chars_only* = false: turns on character dumps (same as -C)
* bool *output.dump_payload* = false: dumps application layer (same as -d)
* bool *output.dump_payload_verbose* = false: dumps raw packet starting at link layer (same as -X)
* int *output.event_trace.max_data* = 0: maximum amount of packet data to capture { 0:65535 }
* string *output.logdir* = .: where to put log files (same as -l)
* bool *output.obfuscate* = false: obfuscate the logged IP addresses (same as -O)
* bool *output.quiet* = false: suppress non-fatal information (still show alerts, same as -q)
* bool *output.show_year* = false: include year in timestamp in the alert and log files (same as -y)
* int *output.tagged_packet_limit* = 256: maximum number of packets tagged for non-packet metrics { 0:max32 }
* bool *output.verbose* = false: be verbose (same as -v)
* bool *output.wide_hex_dump* = false: output 20 bytes per lines instead of 16 when dumping buffers
* bool *packet_capture.enable* = false: initially enable packet dumping
* string *packet_capture.filter*: bpf filter to use for packet dump
* bool *packets.address_space_agnostic* = false: determines whether DAQ address space info is used to track fragments and connections
* string *packets.bpf_file*: file with BPF to select traffic for Snort
* int *packets.limit* = 0: maximum number of packets to process before stopping (0 is unlimited) { 0:max53 }
* int *packets.skip* = 0: number of packets to skip before before processing { 0:max53 }
* bool *packets.vlan_agnostic* = false: determines whether VLAN info is used to track fragments and connections
* bool *packet_tracer.enable* = false: enable summary output of state that determined packet verdict
* enum *packet_tracer.output* = console: select where to send packet trace { console | file }
* string *pcre.~re*: Snort regular expression
* bool *perf_monitor.base* = true: enable base statistics
* bool *perf_monitor.cpu* = false: enable cpu statistics
* bool *perf_monitor.flow* = false: enable traffic statistics
* bool *perf_monitor.flow_ip* = false: enable statistics on host pairs
* int *perf_monitor.flow_ip_memcap* = 52428800: maximum memory in bytes for flow tracking { 8200:maxSZ }
* int *perf_monitor.flow_ports* = 1023: maximum ports to track { 0:65535 }
* enum *perf_monitor.format* = csv: output format for stats { csv | text | json }
* int *perf_monitor.max_file_size* = 1073741824: files will be rolled over if they exceed this size { 4096:max53 }
* string *`perf_monitor.modules[].name`*: name of the module
* string *`perf_monitor.modules[].pegs`*: list of statistics to track or empty for all counters
* enum *perf_monitor.output* = file: output location for stats { file | console }
* int *perf_monitor.packets* = 10000: minimum packets to report { 0:max32 }
* int *perf_monitor.seconds* = 60: report interval { 1:max32 }
* bool *perf_monitor.summary* = false: output summary at shutdown
* int *pop.b64_decode_depth* = 1460: base64 decoding depth (-1 no limit) { -1:65535 }
* int *pop.bitenc_decode_depth* = 1460: Non-Encoded MIME attachment extraction depth (-1 no limit) { -1:65535 }
* bool *pop.decompress_pdf* = false: decompress pdf files in MIME attachments
* bool *pop.decompress_swf* = false: decompress swf files in MIME attachments
* bool *pop.decompress_zip* = false: decompress zip files in MIME attachments
* int *pop.qp_decode_depth* = 1460: Quoted Printable decoding depth (-1 no limit) { -1:65535 }
* int *pop.uu_decode_depth* = 1460: Unix-to-Unix decoding depth (-1 no limit) { -1:65535 }
* bool *port_scan.alert_all* = false: alert on all events over threshold within window if true; else alert on first only
* int *port_scan.icmp_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.icmp_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.icmp_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.icmp_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.icmp_window* = 0: detection interval for all ICMP scans { 0:max32 }
* string *port_scan.ignore_scanned*: list of CIDRs with optional ports to ignore if the destination of scan alerts
* string *port_scan.ignore_scanners*: list of CIDRs with optional ports to ignore if the source of scan alerts
* bool *port_scan.include_midstream* = false: list of CIDRs with optional ports
* int *port_scan.ip_decoy.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_decoy.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_decoy.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_decoy.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_dist.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_dist.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_dist.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_dist.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_proto.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_proto.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_proto.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_proto.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.ip_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.ip_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.ip_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.ip_window* = 0: detection interval for all IP scans { 0:max32 }
* int *port_scan.memcap* = 1048576: maximum tracker memory in bytes { 1:maxSZ }
* multi *port_scan.protos* = all: choose the protocols to monitor { tcp | udp | icmp | ip | all }
* multi *port_scan.scan_types* = all: choose type of scans to look for { portscan | portsweep | decoy_portscan | distributed_portscan | all }
* int *port_scan.tcp_decoy.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_decoy.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_decoy.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_decoy.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_dist.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_dist.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_dist.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_dist.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_ports.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_ports.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_ports.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_ports.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.tcp_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.tcp_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.tcp_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.tcp_window* = 0: detection interval for all TCP scans { 0:max32 }
* int *port_scan.udp_decoy.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_decoy.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_decoy.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_decoy.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_dist.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_dist.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_dist.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_dist.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_ports.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_ports.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_ports.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_ports.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_sweep.nets* = 25: number of times address changed from prior attempt { 0:65535 }
* int *port_scan.udp_sweep.ports* = 25: number of times port (or proto) changed from prior attempt { 0:65535 }
* int *port_scan.udp_sweep.rejects* = 15: scan attempts with negative response { 0:65535 }
* int *port_scan.udp_sweep.scans* = 100: scan attempts { 0:65535 }
* int *port_scan.udp_window* = 0: detection interval for all UDP scans { 0:max32 }
* string *port_scan.watch_ip*: list of CIDRs with optional ports to watch
* int *priority.~*: relative severity level; 1 is highest priority { 1:max31 }
* string *process.chroot*: set chroot directory (same as -t)
* bool *process.daemon* = false: fork as a daemon (same as -D)
* bool *process.dirty_pig* = false: shutdown without internal cleanup
* string *process.set_gid*: set group ID (same as -g)
* string *process.set_uid*: set user ID (same as -u)
* string *`process.threads[].cpuset`*: pin the associated thread to this cpuset
* int *`process.threads[].thread`* = 0: set cpu affinity for the <cur_thread_num> thread that runs { 0:65535 }
* int *process.umask*: set process umask (same as -m) { 0x000:0x1FF }
* bool *process.utc* = false: use UTC instead of local time for timestamps
* int *profiler.memory.count* = 0: limit results to count items per level (0 = no limit) { 0:max32 }
* int *profiler.memory.max_depth* = -1: limit depth to max_depth (-1 = no limit) { -1:255 }
* bool *profiler.memory.show* = true: show module memory profile stats
* enum *profiler.memory.sort* = total_used: sort by given field { none | allocations | total_used | avg_allocation  }
* int *profiler.modules.count* = 0: limit results to count items per level (0 = no limit) { 0:max32 }
* int *profiler.modules.max_depth* = -1: limit depth to max_depth (-1 = no limit) { -1:255 }
* bool *profiler.modules.show* = true: show module time profile stats
* enum *profiler.modules.sort* = total_time: sort by given field { none | checks | avg_check | total_time  }
* int *profiler.rules.count* = 0: print results to given level (0 = all) { 0:max32 }
* bool *profiler.rules.show* = true: show rule time profile stats
* enum *profiler.rules.sort* = total_time: sort by given field { none | checks | avg_check | total_time | matches | no_matches | avg_match | avg_no_match }
* string *`rate_filter[].apply_to`*: restrict filter to these addresses according to track
* int *`rate_filter[].count`* = 1: number of events in interval before tripping { 0:max32 }
* int *`rate_filter[].gid`* = 1: rule generator ID { 0:max32 }
* enum *`rate_filter[].new_action`* = alert: take this action on future hits until timeout { log | pass | alert | drop | block | reset }
* int *`rate_filter[].seconds`* = 1: count interval { 0:max32 }
* int *`rate_filter[].sid`* = 1: rule signature ID { 0:max32 }
* int *`rate_filter[].timeout`* = 1: count interval { 0:max32 }
* enum *`rate_filter[].track`* = by_src: filter only matching source or destination addresses { by_src | by_dst | by_rule }
* bool *react.msg* = false:  use rule msg in response page instead of default message
* string *react.page*: file containing HTTP response (headers and body)
* string *reference.~id*: reference id
* string *reference.~scheme*: reference scheme
* string *`references[].name`*: name used with reference rule option
* string *`references[].url`*: where this reference is defined
* enum *reject.control*: send ICMP unreachable(s) { network|host|port|forward|all }
* enum *reject.reset*: send TCP reset to one or both ends { source|dest|both }
* string *rem.~*: comment
* string *replace.~*: byte code to replace with
* string *reputation.blacklist*: blacklist file name with IP lists
* string *reputation.list_dir*: directory for IP lists and manifest file
* int *reputation.memcap* = 500: maximum total MB of memory allocated { 1:4095 }
* enum *reputation.nested_ip* = inner: IP to use when there is IP encapsulation { inner|outer|all }
* enum *reputation.priority* = whitelist: defines priority when there is a decision conflict during run-time { blacklist|whitelist }
* bool *reputation.scan_local* = false: inspect local address defined in RFC 1918
* string *reputation.whitelist*: whitelist file name with IP lists
* enum *reputation.white* = unblack: specify the meaning of whitelist { unblack|trust }
* int *rev.~*: revision { 1:max32 }
* bool *rewrite.disable_replace* = false: disable replace of packet contents with rewrite rules
* int *rpc.~app*: application number { 0:max32 }
* string *rpc.~proc*: procedure number or * for any
* string *rpc.~ver*: version number or * for any
* enum *`rule_state.([0-9]+):([0-9]+)[].action`* = inherit: apply action if rule matches or inherit from rule definition { log | pass | alert | drop | block | reset | inherit }
* enum *`rule_state.([0-9]+):([0-9]+)[].enable`* = inherit: enable or disable rule in current ips policy or use default defined by ips policy { false | true | inherit }
* int *search_engine.bleedover_port_limit* = 1024: maximum ports in rule before demotion to any-any port group { 1:max32 }
* bool *search_engine.bleedover_warnings_enabled* = false: print warning if a rule is demoted to any-any port group
* bool *search_engine.debug* = false: print verbose fast pattern info
* bool *search_engine.debug_print_nocontent_rule_tests* = false: print rule group info during packet evaluation
* bool *search_engine.debug_print_rule_group_build_details* = false: print rule group info during compilation
* bool *search_engine.debug_print_rule_groups_compiled* = false: prints compiled rule group information
* bool *search_engine.debug_print_rule_groups_uncompiled* = false: prints uncompiled rule group information
* bool *search_engine.detect_raw_tcp* = false: detect on TCP payload before reassembly
* bool *search_engine.enable_single_rule_group* = false: put all rules into one group
* int *search_engine.max_pattern_len* = 0: truncate patterns when compiling into state machine (0 means no maximum) { 0:max32 }
* int *search_engine.max_queue_events* = 5: maximum number of matching fast pattern states to queue per packet { 2:100 }
* dynamic *search_engine.offload_search_method*: set fast pattern offload algorithm - choose available search engine { ac_banded | ac_bnfa | ac_full | ac_sparse | ac_sparse_bands | ac_std }
* dynamic *search_engine.search_method* = ac_bnfa: set fast pattern algorithm - choose available search engine { ac_banded | ac_bnfa | ac_full | ac_sparse | ac_sparse_bands | ac_std }
* bool *search_engine.search_optimize* = true: tweak state machine construction for better performance
* bool *search_engine.show_fast_patterns* = false: print fast pattern info for each rule
* bool *search_engine.split_any_any* = true: evaluate any-any rules separately to save memory
* interval *seq.~range*: check if TCP sequence number is in given range { 0: }
* string *`service.*`*: one or more comma-separated service names
* enum *session.~mode*: output format { printable|binary|all }
* string *sha256.~hash*: data to match
* int *sha256.length*: number of octets in plain text { 1:65535 }
* string *sha256.offset*: var or number of bytes from start of buffer to start search
* implied *sha256.relative* = false: offset from cursor instead of start of buffer
* string *sha512.~hash*: data to match
* int *sha512.length*: number of octets in plain text { 1:65535 }
* string *sha512.offset*: var or number of bytes from start of buffer to start search
* implied *sha512.relative* = false: offset from cursor instead of start of buffer
* string *side_channel.connector*: connector handle
* string *`side_channel.connectors[].connector`*: connector handle
* bit_list *side_channel.ports*: side channel message port list { 65535 }
* int *sid.~*: signature id { 1:max32 }
* bool *sip.ignore_call_channel* = false: enables the support for ignoring audio/video data channel
* int *sip.max_call_id_len* = 256: maximum call id field size { 0:65535 }
* int *sip.max_contact_len* = 256: maximum contact field size { 0:65535 }
* int *sip.max_content_len* = 1024: maximum content length of the message body { 0:65535 }
* int *sip.max_dialogs* = 4: maximum number of dialogs within one stream session { 1:max32 }
* int *sip.max_from_len* = 256: maximum from field size { 0:65535 }
* int *sip.max_requestName_len* = 20: maximum request name field size { 0:65535 }
* int *sip.max_to_len* = 256: maximum to field size { 0:65535 }
* int *sip.max_uri_len* = 256: maximum request uri field size { 0:65535 }
* int *sip.max_via_len* = 1024: maximum via field size { 0:65535 }
* string *`sip_method.*method`*: sip method
* string *sip.methods* = invite cancel ack  bye register options: list of methods to check in SIP messages
* int *`sip_stat_code.*code`*: status code { 1:999 }
* string *`smtp.alt_max_command_line_len[].command`*: command string
* int *`smtp.alt_max_command_line_len[].length`* = 0: specify non-default maximum for command { 0:max32 }
* string *smtp.auth_cmds*: commands that initiate an authentication exchange
* int *smtp.b64_decode_depth* = 1460: depth used to decode the base64 encoded MIME attachments (-1 no limit) { -1:65535 }
* string *smtp.binary_data_cmds*: commands that initiate sending of data and use a length value after the command
* int *smtp.bitenc_decode_depth* = 1460: depth used to extract the non-encoded MIME attachments (-1 no limit) { -1:65535 }
* string *smtp.data_cmds*: commands that initiate sending of data with an end of data delimiter
* bool *smtp.decompress_pdf* = false: decompress pdf files in MIME attachments
* bool *smtp.decompress_swf* = false: decompress swf files in MIME attachments
* bool *smtp.decompress_zip* = false: decompress zip files in MIME attachments
* int *smtp.email_hdrs_log_depth* = 1464: depth for logging email headers { 0:20480 }
* bool *smtp.ignore_data* = false: ignore data section of mail
* bool *smtp.ignore_tls_data* = false: ignore TLS-encrypted data when processing rules
* string *smtp.invalid_cmds*: alert if this command is sent from client side
* bool *smtp.log_email_hdrs* = false: log the SMTP email headers extracted from SMTP data
* bool *smtp.log_filename* = false: log the MIME attachment filenames extracted from the Content-Disposition header within the MIME body
* bool *smtp.log_mailfrom* = false: log the sender's email address extracted from the MAIL FROM command
* bool *smtp.log_rcptto* = false: log the recipient's email address extracted from the RCPT TO command
* int *smtp.max_auth_command_line_len* = 1000: max auth command Line Length { 0:65535 }
* int *smtp.max_command_line_len* = 0: max Command Line Length { 0:65535 }
* int *smtp.max_header_line_len* = 0: max SMTP DATA header line { 0:65535 }
* int *smtp.max_response_line_len* = 0: max SMTP response line { 0:65535 }
* string *smtp.normalize_cmds*: list of commands to normalize
* enum *smtp.normalize* = none: turns on/off normalization { none | cmds | all }
* int *smtp.qp_decode_depth* = 1460: quoted-Printable decoding depth (-1 no limit) { -1:65535 }
* int *smtp.uu_decode_depth* = 1460: Unix-to-Unix decoding depth (-1 no limit) { -1:65535 }
* string *smtp.valid_cmds*: list of valid commands
* enum *smtp.xlink2state* = alert: enable/disable xlink2state alert { disable | alert | drop }
* implied *snort.--alert-before-pass*: process alert, drop, sdrop, or reject before pass; default is pass before alert, drop,...
* string *snort.-A*: <mode> set alert mode: none, cmg, or alert_*
* addr *snort.-B* = 255.255.255.255/32: <mask> obfuscated IP addresses in alerts and packet dumps using CIDR mask
* string *snort.--bpf*: <filter options> are standard BPF options, as seen in TCPDump
* string *snort.--c2x*: output hex for given char (see also --x2c)
* string *snort.-c*: <conf> use this configuration
* implied *snort.-C*: print out payloads with character data only (no hex)
* implied *snort.--create-pidfile*: create PID file, even when not in Daemon mode
* string *snort.--daq-dir*: <dir> tell snort where to find desired DAQ
* implied *snort.--daq-list*: list packet acquisition modules available in optional dir, default is static modules only
* string *snort.--daq*: <type> select packet acquisition module (default is pcap)
* string *snort.--daq-var*: <name=value> specify extra DAQ configuration variable
* implied *snort.-d*: dump the Application Layer
* implied *snort.--dirty-pig*: don't flush packets on shutdown
* implied *snort.-D*: run Snort in background (daemon) mode
* string *snort.--dump-builtin-rules*: [<module prefix>] output stub rules for selected modules { (optional) }
* string *snort.--dump-defaults*: [<module prefix>] output module defaults in Lua format { (optional) }
* implied *snort.--dump-dynamic-rules*: output stub rules for all loaded rules libraries
* implied *snort.--dump-version*: output the version, the whole version, and only the version
* implied *snort.-e*: display the second layer header info
* implied *snort.--enable-inline-test*: enable Inline-Test Mode Operation
* implied *snort.-f*: turn off fflush() calls after binary log writes
* int *snort.-G*: <0xid> (same as --logid) { 0:65535 }
* implied *snort.--gen-msg-map*: dump builtin rules in gen-msg.map format for use by other tools
* string *snort.-g*: <gname> run snort gid as <gname> group (or gid) after initialization
* string *snort.--help-commands*: [<module prefix>] output matching commands { (optional) }
* string *snort.--help-config*: [<module prefix>] output matching config options { (optional) }
* string *snort.--help-counts*: [<module prefix>] output matching peg counts { (optional) }
* implied *snort.--help-limits*: print the int upper bounds denoted by max*
* implied *snort.--help*: list command line options
* string *snort.--help-module*: <module> output description of given module
* implied *snort.--help-modules*: list all available modules with brief help
* string *snort.--help-options*: [<option prefix>] output matching command line option quick help (same as -?) { (optional) }
* implied *snort.--help-plugins*: list all available plugins with brief help
* implied *snort.--help-signals*: dump available control signals
* implied *snort.-H*: make hash tables deterministic
* int *snort.--id-offset* = 0: offset to add to instance IDs when logging to files { 0:65535 }
* implied *snort.--id-subdir*: create/use instance subdirectories in logdir instead of instance filename prefix
* implied *snort.--id-zero*: use id prefix / subdirectory even with one packet thread
* string *snort.-i*: <iface>... list of interfaces
* enum *snort.-k* = all: <mode> checksum mode; default is all { all|noip|notcp|noudp|noicmp|none }
* implied *snort.--list-buffers*: output available inspection buffers
* string *snort.--list-builtin*: [<module prefix>] output matching builtin rules { (optional) }
* string *snort.--list-gids*: [<module prefix>] output matching generators { (optional) }
* string *snort.--list-modules*: [<module type>] list all known modules of given type { (optional) }
* implied *snort.--list-plugins*: list all known plugins
* string *snort.-l*: <logdir> log to this directory instead of current directory
* string *snort.-L*: <mode> logging mode (none, dump, pcap, or log_*)
* int *snort.--logid*: <0xid> log Identifier to uniquely id events for multiple snorts (same as -G) { 0:65535 }
* string *snort.--lua*: <chunk> extend/override conf with chunk; may be repeated
* implied *snort.--markup*: output help in asciidoc compatible format
* int *snort.--max-packet-threads* = 1: <count> configure maximum number of packet threads (same as -z) { 0:max32 }
* implied *snort.--mem-check*: like -T but also compile search engines
* implied *snort.-M*: log messages to syslog (not alerts)
* int *snort.-m*: <umask> set the process file mode creation mask { 0x000:0x1FF }
* int *snort.-n*: <count> stop after count packets { 0:max53 }
* implied *snort.--nolock-pidfile*: do not try to lock Snort PID file
* implied *snort.--nostamps*: don't include timestamps in log file names
* implied *snort.-O*: obfuscate the logged IP addresses
* string *snort.-?*: <option prefix> output matching command line option quick help (same as --help-options) { (optional) }
* implied *snort.--parsing-follows-files*: parse relative paths from the perspective of the current configuration file
* implied *snort.--pause*: wait for resume/quit command before processing packets/terminating
* string *snort.--pcap-dir*: <dir> a directory to recurse to look for pcaps - read mode is implied
* string *snort.--pcap-file*: <file> file that contains a list of pcaps to read - read mode is implied
* string *snort.--pcap-filter*: <filter> filter to apply when getting pcaps from file or directory
* string *snort.--pcap-list*: <list> a space separated list of pcaps to read - read mode is implied
* int *snort.--pcap-loop*: <count> read all pcaps <count> times;  0 will read until Snort is terminated { 0:max32 }
* implied *snort.--pcap-no-filter*: reset to use no filter when getting pcaps from file or directory
* implied *snort.--pcap-reload*: if reading multiple pcaps, reload snort config between pcaps
* implied *snort.--pcap-show*: print a line saying what pcap is currently being read
* implied *snort.--pedantic*: warnings are fatal
* string *snort.--plugin-path*: <path> where to find plugins
* implied *snort.--process-all-events*: process all action groups
* implied *snort.-Q*: enable inline mode operation
* implied *snort.-q*: quiet mode - Don't show banner and status report
* string *snort.-r*: <pcap>... (same as --pcap-list)
* string *snort.-R*: <rules> include this rules file in the default policy
* string *snort.--rule-path*: <path> where to find rules files
* string *snort.--rule*: <rules> to be added to configuration; may be repeated
* implied *snort.--rule-to-hex*: output so rule header to stdout for text rule on stdin
* string *snort.--rule-to-text*: output plain so rule header to stdout for text rule on stdin (specify delimiter or [Snort_SO_Rule] will be used) { 16 }
* string *snort.--run-prefix*: <pfx> prepend this to each output file
* int *snort.-s* = 1518: <snap> (same as --snaplen); default is 1518 { 68:65535 }
* string *snort.--script-path*: <path> to a luajit script or directory containing luajit scripts
* implied *snort.--show-plugins*: list module and plugin versions
* int *snort.--skip*: <n> skip 1st n packets { 0:max53 }
* int *snort.--snaplen* = 1518: <snap> set snaplen of packet (same as -s) { 68:65535 }
* implied *snort.--stdin-rules*: read rules from stdin until EOF or a line starting with END is read
* string *snort.-S*: <x=v> set config variable x equal to value v
* implied *snort.--talos*: enable Talos inline rule test mode (same as --tweaks talos -Q -q)
* string *snort.-t*: <dir> chroots process to <dir> after initialization
* int *snort.trace*: mask for enabling debug traces in module { 0:max53 }
* implied *snort.--trace*: turn on main loop debug trace
* implied *snort.--treat-drop-as-alert*: converts drop, sdrop, and reject rules into alert rules during startup
* implied *snort.--treat-drop-as-ignore*: use drop, sdrop, and reject rules to ignore session traffic when not inline
* implied *snort.-T*: test and report on the current Snort configuration
* string *snort.--tweaks*: tune configuration
* string *snort.-u*: <uname> run snort as <uname> or <uid> after initialization
* implied *snort.-U*: use UTC for timestamps
* implied *snort.-v*: be verbose
* implied *snort.--version*: show version number (same as -V)
* implied *snort.-V*: (same as --version)
* implied *snort.--warn-all*: enable all warnings
* implied *snort.--warn-conf*: warn about configuration issues
* implied *snort.--warn-daq*: warn about DAQ issues, usually related to mode
* implied *snort.--warn-flowbits*: warn about flowbits that are checked but not set and vice-versa
* implied *snort.--warn-hosts*: warn about host table issues
* implied *snort.--warn-plugins*: warn about issues that prevent plugins from loading
* implied *snort.--warn-rules*: warn about duplicate rules and rule parsing issues
* implied *snort.--warn-scripts*: warn about issues discovered while processing Lua scripts
* implied *snort.--warn-symbols*: warn about unknown symbols in your Lua config
* implied *snort.--warn-vars*: warn about variable definition and usage issues
* int *snort.--x2c*: output ASCII char for given hex (see also --c2x) { 0x00:0xFF }
* string *snort.--x2s*: output ASCII string for given byte code (see also --x2c)
* implied *snort.-X*: dump the raw packet data starting at the link layer
* implied *snort.-x*: same as --pedantic
* implied *snort.-y*: include year in timestamp in the alert and log files
* int *snort.-z* = 1: <count> maximum number of packet threads (same as --max-packet-threads); 0 gets the number of CPU cores reported by the system; default is 1 { 0:max32 }
* string *so.~func*: name of eval function
* string *soid.~*: SO rule ID is unique key, eg <gid>_<sid>_<rev> like 3_45678_9
* int *ssh.max_client_bytes* = 19600: number of unanswered bytes before alerting on challenge-response overflow or CRC32 { 0:65535 }
* int *ssh.max_encrypted_packets* = 25: ignore session after this many encrypted packets { 0:65535 }
* int *ssh.max_server_version_len* = 80: limit before alerting on secure CRT server version string overflow { 0:255 }
* int *ssl.max_heartbeat_length* = 0: maximum length of heartbeat record allowed { 0:65535 }
* implied *ssl_state.client_hello*: check for client hello
* implied *ssl_state.!client_hello*: check for records that are not client hello
* implied *ssl_state.client_keyx*: check for client keyx
* implied *ssl_state.!client_keyx*: check for records that are not client keyx
* implied *ssl_state.!server_hello*: check for records that are not server hello
* implied *ssl_state.server_hello*: check for server hello
* implied *ssl_state.!server_keyx*: check for records that are not server keyx
* implied *ssl_state.server_keyx*: check for server keyx
* implied *ssl_state.!unknown*: check for records that are not unknown
* implied *ssl_state.unknown*: check for unknown record
* bool *ssl.trust_servers* = false: disables requirement that application (encrypted) data must be observed on both sides
* implied *ssl_version.!sslv2*: check for records that are not sslv2
* implied *ssl_version.sslv2*: check for sslv2
* implied *ssl_version.!sslv3*: check for records that are not sslv3
* implied *ssl_version.sslv3*: check for sslv3
* implied *ssl_version.!tls1.0*: check for records that are not tls1.0
* implied *ssl_version.tls1.0*: check for tls1.0
* implied *ssl_version.!tls1.1*: check for records that are not tls1.1
* implied *ssl_version.tls1.1*: check for tls1.1
* implied *ssl_version.!tls1.2*: check for records that are not tls1.2
* implied *ssl_version.tls1.2*: check for tls1.2
* int *stream.file_cache.cap_weight* = 32: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.file_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.file_cache.max_sessions* = 128: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.file_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* bool *stream_file.upload* = false: indicate file transfer direction
* int *stream.footprint* = 0: use zero for production, non-zero for testing at given size (for TCP and user) { 0:max32 }
* int *stream.icmp_cache.cap_weight* = 8: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.icmp_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.icmp_cache.max_sessions* = 65536: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.icmp_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream_icmp.session_timeout* = 30: session tracking timeout { 1:max31 }
* int *stream.ip_cache.cap_weight* = 64: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.ip_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.ip_cache.max_sessions* = 16384: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.ip_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* bool *stream.ip_frags_only* = false: don't process non-frag flows
* int *stream_ip.max_frags* = 8192: maximum number of simultaneous fragments being tracked { 1:max32 }
* int *stream_ip.max_overlaps* = 0: maximum allowed overlaps per datagram; 0 is unlimited { 0:max32 }
* int *stream_ip.min_frag_length* = 0: alert if fragment length is below this limit before or after trimming { 0:65535 }
* int *stream_ip.min_ttl* = 1: discard fragments with TTL below the minimum { 1:255 }
* enum *stream_ip.policy* = linux: fragment reassembly policy { first | linux | bsd | bsd_right | last | windows | solaris }
* int *stream_ip.session_timeout* = 30: session tracking timeout { 1:max31 }
* int *stream_ip.trace*: mask for enabling debug traces in module { 0:max53 }
* enum *stream_reassemble.action*: stop or start stream reassembly { disable|enable }
* enum *stream_reassemble.direction*: action applies to the given direction(s) { client|server|both }
* implied *stream_reassemble.fastpath*: optionally whitelist the remainder of the session
* implied *stream_reassemble.noalert*: don't alert when rule matches
* enum *stream_size.~direction*: compare applies to the given direction(s) { either|to_server|to_client|both }
* interval *stream_size.~range*: check if the stream size is in the given range { 0: }
* int *stream.tcp_cache.cap_weight* = 11500: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.tcp_cache.idle_timeout* = 3600: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.tcp_cache.max_sessions* = 262144: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.tcp_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream_tcp.flush_factor* = 0: flush upon seeing a drop in segment size after given number of non-decreasing segments { 0:65535 }
* int *stream_tcp.max_pdu* = 16384: maximum reassembled PDU size { 1460:32768 }
* int *stream_tcp.max_window* = 0: maximum allowed TCP window { 0:1073725440 }
* int *stream_tcp.overlap_limit* = 0: maximum number of allowed overlapping segments per session { 0:max32 }
* enum *stream_tcp.policy* = bsd: determines operating system characteristics like reassembly { first | last | linux | old_linux | bsd | macos | solaris | irix | hpux11 | hpux10 | windows | win_2003 | vista | proxy }
* int *stream_tcp.queue_limit.max_bytes* = 1048576: don't queue more than given bytes per session and direction { 0:max32 }
* int *stream_tcp.queue_limit.max_segments* = 2621: don't queue more than given segments per session and direction { 0:max32 }
* bool *stream_tcp.reassemble_async* = true: queue data for reassembly before traffic is seen in both directions
* int *stream_tcp.require_3whs* = -1: don't track midstream sessions after given seconds from start up; -1 tracks all { -1:max31 }
* int *stream_tcp.session_timeout* = 30: session tracking timeout { 1:max31 }
* bool *stream_tcp.show_rebuilt_packets* = false: enable cmg like output of reassembled packets
* int *stream_tcp.small_segments.count* = 0: limit number of small segments queued { 0:2048 }
* int *stream_tcp.small_segments.maximum_size* = 0: limit number of small segments queued { 0:2048 }
* bool *stream_tcp.track_only* = false: disable reassembly if true
* int *stream.trace*: mask for enabling debug traces in module { 0:max53 }
* int *stream.udp_cache.cap_weight* = 128: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.udp_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.udp_cache.max_sessions* = 131072: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.udp_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream_udp.session_timeout* = 30: session tracking timeout { 1:max31 }
* int *stream.user_cache.cap_weight* = 256: additional bytes to track per flow for better estimation against cap { 0:65535 }
* int *stream.user_cache.idle_timeout* = 180: maximum inactive time before retiring session tracker { 1:max32 }
* int *stream.user_cache.max_sessions* = 1024: maximum simultaneous sessions tracked before pruning { 2:max32 }
* int *stream.user_cache.pruning_timeout* = 30: minimum inactive time before being eligible for pruning { 1:max32 }
* int *stream_user.session_timeout* = 30: session tracking timeout { 1:max31 }
* int *stream_user.trace*: mask for enabling debug traces in module { 0:max53 }
* int *`suppress[].gid`* = 0: rule generator ID { 0:max32 }
* string *`suppress[].ip`*: restrict suppression to these addresses according to track
* int *`suppress[].sid`* = 0: rule signature ID { 0:max32 }
* enum *`suppress[].track`*: suppress only matching source or destination addresses { by_src | by_dst }
* int *tag.bytes*: tag for this many bytes { 1:max32 }
* enum *tag.~*: log all packets in session or all packets to or from host { session|host_src|host_dst }
* int *tag.packets*: tag this many packets { 1:max32 }
* int *tag.seconds*: tag for this many seconds { 1:max32 }
* enum *target.~*: indicate the target of the attack { src_ip | dst_ip }
* string *tcp_connector.address*: address
* port *tcp_connector.base_port*: base port number
* string *tcp_connector.connector*: connector name
* enum *tcp_connector.setup*: stream establishment { call | answer }
* int *telnet.ayt_attack_thresh* = -1: alert on this number of consecutive Telnet AYT commands { -1:max31 }
* bool *telnet.check_encrypted* = false: check for end of encryption
* bool *telnet.encrypted_traffic* = false: check for encrypted Telnet and FTP
* bool *telnet.normalize* = false: eliminate escape sequences
* interval *tos.~range*: check if IP TOS is in given range { 0:255 }
* interval *ttl.~range*: check if IP TTL is in the given range { 0:255 }
* bool *udp.deep_teredo_inspection* = false: look for Teredo on all UDP ports (default is only 3544)
* bool *udp.enable_gtp* = false: decode GTP encapsulations
* bit_list *udp.gtp_ports* = 2152 3386: set GTP ports { 65535 }
* bool *unified2.legacy_events* = false: generate Snort 2.X style events for barnyard2 compatibility
* int *unified2.limit* = 0: set maximum size in MB before rollover (0 is unlimited) { 0:maxSZ }
* bool *unified2.nostamp* = true: append file creation time to name (in Unix Epoch format)
* interval *window.~range*: check if TCP window size is in given range { 0:65535 }
* multi *wizard.curses*: enable service identification based on internal algorithm { dce_smb | dce_udp | dce_tcp }
* bool *`wizard.hexes[].client_first`* = true: which end initiates data transfer
* select *`wizard.hexes[].proto`* = tcp: protocol to scan { tcp | udp }
* string *`wizard.hexes[].service`*: name of service
* string *`wizard.hexes[].to_client[].hex`*: sequence of data with wild chars (?)
* string *`wizard.hexes[].to_server[].hex`*: sequence of data with wild chars (?)
* bool *`wizard.spells[].client_first`* = true: which end initiates data transfer
* select *`wizard.spells[].proto`* = tcp: protocol to scan { tcp | udp }
* string *`wizard.spells[].service`*: name of service
* string *`wizard.spells[].to_client[].spell`*: sequence of data with wild cards (*)
* string *`wizard.spells[].to_server[].spell`*: sequence of data with wild cards (*)
