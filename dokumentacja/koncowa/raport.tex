%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Simple and elegant academic report    %
%   Copyright by Artur M. Brodzki, 2019   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{eiti-raport}

\usepackage[
	english,
	polish
]{babel}
\usepackage{polski}
\usepackage{listings}

\addbibresource{bibliografia.bib}

%------------------------------------------

\begin{document}

\author{Artur M. Brodzki \\ Damian Chiliński \\ Krzysztof Sznejder}
\date{\today}
\subject{BCYB 19L}
\title{Projekt -- dokumentacja koŃcowa}
\fancyhead[L]{Brodzki, Chiliński, Sznejder}
\fancyhead[R]{BCYB 19L}

\pagenumbering{arabic}
\maketitle

%------------------------------------------
% MAIN CONTENTS
%------------------------------------------

\section{Wstęp} \label{sec:intro}
Zgodnie z przyjętym przez nas tematem, w ramach projektu napisaliśmy moduł systemu IDS/IPS Snort, wykrywający steganograficzną transmisję danych metodą tunelowania DNS. Przetestowaliśmy również jego działanie w wirtualnym środowisku, symulującym sieć korporacyjną. 

\section{Tunelowanie DNS} \label{sec:2}

\subsection{Zasada działania} \label{sec:tunelowanie}
Tunelowanie DNS należy do metod steganograficznych i pozwala na prowadzenie niewidocznej dla administratorów transmisji danych, np. przesłanie na maszynę atakującego wykradzionych plików. Zasada działania opiera się na redundancji protokołu DNS. Typowy przebieg ataku z wykorzystaniem tunelowania DNS jest następujący \cite{infosec}:
\begin{enumerate}
	\item Atakujący rejestruje domenę, np. \texttt{best-malware.com} i tworzy dla niej własny serwer autorytatywny. 
	\item Atakujący instaluje złośliwe oprogramowanie na systemach ofiary, które wykrada z nich wrażliwe dane, np. hasło bankowe. 
	\item Oprogramowanie atakującego koduje uzyskane informacje jako subdomenę, np: \\  \texttt{76756C6E657261626C65.bestmalware.win} i wysyła odpowiadające jej zapytanie DNS. Trafia ono na serwer atakującego, który może odebrać i zdekodować ukryte informacje. Dane można kodować zasadniczo w formacie Base16 (HEX) lub Base32. Wynika to ze specyfikacji protokołu DNS, który dopuszcza w zapytaniach ograniczony zestaw znaków. 
	\item Aby przeprowadzić transmisję w drugą stronę, wystarczy zakodować informacje w pakiecie będącym odpowiedzią na zapytanie. Najczęściej będzie to więc pakiet typu A, choć możliwe jest kodowanie danych z użyciem każdego typu rekordu DNS. 
\end{enumerate}
Skuteczność tego ataku wynika z kluczowej roli, jaką odgrywa DNS w komunikacji internetowej. Jego zablokowanie może uniemożliwić działanie sieci, dlatego zapytania DNS bardzo rzadko są ograniczane przez administratorów, i to nawet w sieciach o restrykcyjnych wymogach bezpieczeństwa. 

\subsection{Metody wykrywania} \label{sec:wykrywanie}
Aby skutecznie zablokować transmisję wykorzystującą tunelowanie DNS, konieczne jest wiarygodne odróżnienie złośliwych zapytań DNS od tych prawidłowych. Stosuje się w tym celu różne heurystyki, oparte m.in. o:
\begin{itemize}
	\item analizę długości i entropii zapytania -- większość ,,normalnych'' domen nie przekracza kilkunastu znaków i charakteryzuje się niewielką entropią, typową dla słów pochodzących z języka naturalnego;
	\item analizę częstości -- znaczący wzrost liczby wykonywanych zapytań DNS może sugerować, że część z nich jest niepożądana;
	\item metody słownikowe -- ,,prawdziwe'' domeny zazwyczaj składają się ze słów pochodzących z języka naturalnego lub zbudowanych na ich podstawie neologizmów;
	\item uczenie maszynowe.
\end{itemize}
W naszym projekcie zdecydowaliśmy się wykorzystać autorski algorytm uczenia maszynowego oparty o naiwny klasyfikator Bayesa. Klasyfikator został nauczony na zbiorze zapytań DNS wygenerowanych i przechwyconych przez nas podczas kilku tygodni codziennego użytkowania naszych domowych komputerów. Szczegółowy opis algorytmu znajduje się w rozdziale \ref{sec:implementacja-plugin} 

\section{Scenariusz projektowy} \label{sec:scenariusz}
Zaplanowaliśmy następujący scenariusz projektowy: firma B-Cyb S.A dysponuje siecią korporacyjną, działającą w domenie \texttt{bcyb.com}. W ramach świadczonych usług, posiada dwa publicznie dostępne serwery HTTP, kolejno: \texttt{s1.bcyb.com} oraz \texttt{s2.bcyb.com}. Dostęp do firmowej sieci chroniony jest za pomocą firewalla działającego na firmowym routerze oraz systemu IDS/IPS Snort, filtrującego ruch przepływający przez sieć. Ponieważ firma B-Cyb obawia się ataku metodą tunelowania DNS, zakupiła od młodego zespołu specjalistów (Kant Security sp. z.o.o) dodatkowy moduł systemu Snort, mający wykrywać i blokować tego rodzaju ataki. W ramach sieci firmowej została wydzielona podsieć, chroniona -- w celach testowych -- przy użyciu nowego modułu. 

Na firmowych serwerach znajduje się złośliwe oprogramowanie, którego zadaniem jest przetransmitować na serwery atakującego wykradzione pliki \texttt{/etc/shadow}. Ponieważ wyprowadzenie danych poza sieć za pomocą protokołu TCP jest niemożliwe, atakujący zdecydowali się zastosować właśnie tunelowanie DNS. Podczas próby przesłania wykradzionych haseł, nowy moduł Snorta od zespołu Kant Security wykryje i zablokuje złośliwą transmisję. Natomiast podsieć chroniona za pomocą dotychczasowej wersji systemu Snort nie wykryje ataku i pozwoli na wyprowadzenie haseł na zewnątrz. 

Całość infrastruktury projektowej została zainstalowana przez nas na maszynach wirtualnych VMware i obejmuje łącznie 9 hostów, znajdujących się pod kontrolą systemu Fedora 30. Szczegółowa topologia sieci znajduje się na rys. \ref{fig:topologia}. 
\begin{figure}[!h] \centering
	\includegraphics[width=0.9\linewidth]{img/BCYB_topologia.png}
	\caption{Schemat ideowy sieci, realizującej przyjęty scenariusz projektowy.} \label{fig:topologia}
\end{figure}
Przygotowana infrastruktura składa się z następujących urządzeń: 
\begin{itemize}
	\item router ROS: domyślna brama sieciowa dla sieci firmowej, działa pod kontrolą systemu MikroTik RouterOS i obsługuje zaporę sieciową;
	\item IDNS: firmowy serwer DNS;
	\item SRV1 i SRV2: publicznie dostępne serwery HTTP;
	\item IPS1 i IPS2: hosty systemu Snort, działające w trybie inline i filtrujące ruch przechodzący przez sieć;
	\item USR1 i USR2: komputery użytkowe, służące pracownikom firmy do wykonywania obowiązków służbowych, w tym zarządzania pozostałymi hostami;
	\item MDNS: komputer atakującego, stanowiący punkt odbiorczy ukrytej komunikacji. 
\end{itemize}
Zapora sieciowa posiada następującą konfigurację:
\begin{enumerate}
	\item sieć firmowa (corporate network, 10.0.0.0/8) podzielona jest na strefę zdemilitaryzowaną (DMZ) oraz sieć wewnętrzną (INET);
	\item strefa zdemilitaryzowana: obejmuje publicznie dostępne serwery DNS i HTTP (IDNS, SRV1, SRV2), jak również chroniące je hosty systemu Snort.
	\begin{itemize}
		\item ruch wchodzący: dopuszczony jest jedynie ruch realizujący świadczone usługi, oraz ruch SSH pochodzący z sieci INET;
		\item ruch wychodzący: zabronione jest inicjowanie ruchu w obrębie DMZ, z wyjątkiem zapytań DNS oraz ruchu wychodzącego do serwerów zawierających repozytoria Fedory. Dopuszczony jest zatem jedynie ruch wymagany do pobierania aktualizacji oprogramowania systemowego;
	\end{itemize}
	\item sieć wewnętrzna: obejmuje komputery służbowe USR1 i USR2:
	\begin{itemize}
		\item ruch wchodzący: jest zasadniczo zabroniony w każdym przypadku i na wszystkich portach, dopuszczony jest jednak rzecz jasna ruch powrotny w ramach połączeń zainicjowanych przez hosty sieci INET (\texttt{connection-state = establieshed, related}).
		\item ruch wychodzący: co do zasady nie jest filtrowany, z wyjątkiem ograniczeń wymuszonych przez zaporę dla ruchu wchodzącego do DMZ.
	\end{itemize}
\end{enumerate}
Z uwagi na nietrywialną złożoność wirtualizowanej infrastruktury, istotne jest określenie wymagań sprzętowych. Szczególnie ważna jest ilość pamięci operacyjnej, wymagana do działania poszczególnych hostów:
\begin{itemize}
	\item każdy z hostów posiadających graficzny interfejs użytkownika (USR1, USR2, MDNS) wymaga 2 GB pamięci RAM;
	\item hosty systemu Snort (IPS1, IPS2) wymagają do sprawnego działania po 768 MB pamięci RAM każdy;
	\item serwery HTTP (SRV1, SRV2) zajmują po 512 MB pamięci;
	\item do działania serwera DNS (IDNS) konieczne jest 512 MB, a dla routera ROS -- 256 MB pamięci RAM.
\end{itemize}
Doliczając do tego pamięć systemu gospodarza okazuje się, że dla uruchomienia całej wymaganej infrastruktury niezbędne jest co najmniej 12 GB pamięci operacyjnej. W praktyce będzie to zazwyczaj 16 GB. 

Istotnym zagadnieniem był również wybór wersji systemu Snort. Aktualna wersja stabilna to 2.9.13, jednak prace deweloperskie koncentrują się na Snorcie 3, który wciąż znajduje się w wersji beta, a data jego finalnego wydania pozostaje nieznana. Snort 3 jest zupełnie nowym programem napisanym od zera i niekompatybilnym wstecznie ze Snortem 2. Z punktu widzenia naszego projektu charakteryzuje się jednak ważną zaletą: jego API zostało zaprojektowane z myślą o tworzeniu wtyczek rozszerzających funkcjonalność systemu. Pomimo znacznych braków w dokumentacji zdecydowaliśmy się zatem na przygotowanie naszej wtyczki dla Snorta 3. 

\section{Implementacja} \label{sec:implementation}

\subsection{Aplikacja nadawcza i odbiorcza} \label{sec:implementacja-dnstools}
Aplikacje nadawcza i odbiorcza, realizujące transmisję metodą tunelowania DNS, znajdują się w repozytorium projektu w katalogu \texttt{./dns\_tools}:
\begin{itemize}
	\item skrypt \texttt{dnsenc.sh} stanowi aplikację nadawczą i przyjmuje dwa argumenty, kolejno: plik do wysłania i domenę docelową. Jego działanie polega na zakodowaniu wysyłanego pliku w formacie Base16 i podzieleniu go na 8-znakowe fragmenty. Każdy fragment wysyłany jest jako subdomena zapytania DNS, jak opisano w rozdziale \ref{sec:tunelowanie}. Zapytania DNS generowane są za pomocą dostępnego w systemie Linux narzędzia \texttt{nslookup}. 
	\item skrypt \texttt{dnsdec.js} jest napisany jako skrypt NodeJS i stanowi aplikację odbiorczą. Przyjmuje jeden argument: domenę, dla której nasłuchujemy przychodzących zapytań. Zdekodowane dane wypisywane są domyślnie na standardowe wejście, skąd mogą zostać przekierowane do pliku. 
\end{itemize}

\subsection{Podstawowy algorytm klasyfikacji} \label{sec:implementacja-bayes}
Algorytm klasyfikacji zapytań DNS wykorzystuje naiwny klasyfikator Bayesa na n-gramach. Działanie klasyfikatora opiera się na obserwacji, że pewne sekwencje znaków (n-gramy) występują znacznie częściej w ,,naturalnych'' domenach DNS niż w zakodowanych danych binarnych, a inne -- odwrotnie. Zdecydowaliśmy się wykorzystać n-gramy długości 3, jako kompromis pomiędzy dokładnością klasyfikatora a wymaganą złożonością obliczeniową. W naszym zbiorze występują subdomeny używające łącznie 38 znaków, możliwe są więc 54 872 różne trójznaki, z czego 37 425 istotnie wystąpiło przynajmniej raz w zbiorze uczącym. 

Częstości najczęściej występujących trójznaków dla obu przypadków przedstawione są (w skali logarytmicznej) na rys. \ref{fig:engrams-hist}. Widoczne jest, że o ile w przypadku danych binarnych wszystkie trójznaki występują z niemal identyczną częstością (duża entropia rozkładu), to dla ,,naturalnych'' domen DNS zachodzi znaczna koncentracja: istnieje pewien niewielki zbiór trójznaków o znacznej częstości i wiele innych występujących bardzo rzadko (mała entropia rozkładu). 
\begin{figure}[!h] \centering
	\includegraphics[width=0.9\linewidth]{img/engrams-hist.PNG}
	\caption{Częstości występowania najczęstszych trójznaków w obu klasach zapytań.} \label{fig:engrams-hist}
\end{figure}
Widoczny dla danych binarnych ,,uskok'' w połowie wykresu wynika z obecności w zbiorze uczącym dwóch metod kodowania, tj. Base16 i Base32. Ponieważ zbiór znaków kodowania szesnastkowego niemal w całości zawiera się w zbiorze znaków dopuszczalnych dla kodowania Base32, to pewne trójznaki możliwe są w obu metodach kodowania (np. 456, AAA), natomiast inne -- możliwe są tylko w kodowaniu Base32 (np. ZZZ). Te drugie są odpowiednio rzadsze. 

Klasyfikator rozpoznaje dwie klasy zapytań: poprawnych (\emph{negative}) lub złośliwych (\emph{positive})\footnote{Ponieważ głównym zadaniem klasyfikatora jest odróżnienie nielicznych domen złośliwych od domen poprawnych, przyjęliśmy, że jego główną klasą -- klasą \emph{positive} -- jest klasa zapytań złośliwych.}. Klasyfikator może popełnić dwa rodzaje błędów: \emph{false-positive} i \emph{false-negative}. Należy zauważyć, że w naszym przypadku koszt błędu typu \emph{false-positive} jest znacznie większy, niż \emph{false-negative}. W przypadku przepuszczenia kilku złośliwych zapytań grozi nam co najwyżej przesłanie niewielkiej ilości wykradzionych danych, rzędu kilka-kilkanaście bajtów, natomiast w przypadku zablokowania zapytań poprawnych grozi nam utrata funkcjonalności sieci. Z tego względu istotne jest maksymalne zwiększenie precyzji klasyfikatora, nawet kosztem jego mniejszej czułości (ang. \emph{precision and recall}). 

Podstawowym parametrem wpływającym na jakość klasyfikacji zadanej subdomeny jest jej długość: dłuższe domeny znacznie łatwiej jest poprawnie sklasyfikować, ze względu na większą ilość dostępnej informacji. W skrajnym przypadku domeny jednoznakowej np. \texttt{a.best-malware.com} niemożliwe jest stwierdzenie, czy jest to naturalne zapytanie, czy też stanowi ono 4 bity danych binarnych w formacie Base16, lub 5 bitów w formacie Base32. Ze względu na wykorzystanie przez nas trójznaków, minimalna długość subdomeny, jaką nasz klasyfikator jest w stanie sklasyfikować, wynosi 3. Nie stanowi to zagrożenia bezpieczeństwa, ponieważ ze względu na działanie cache'a serwerów DNS przesłanie większej ilości danych za pomocą krótszych domen jest niemożliwe. Można rozważać podniesienie tego limitu, w celu uniknięcia błędów typu \emph{false-positive} i zwiększenia precyzji. Rys. \ref{fig:length-hist} przedstawia histogram częstości subdomen w zależności od ich długości. 
\begin{figure}[!h] \centering
	\includegraphics[width=0.9\linewidth]{img/length-hist.PNG}
	\caption{Histogram długości subdomen w ,,naturalnych'' zapytaniach DNS.} \label{fig:length-hist}
\end{figure}
Widoczna jest wyraźna dominanta rozkładu dla 3 znaków, co wynika z tego, że zdecydowanie najczęstszą subdomeną jest \texttt{www}, oraz częste występowanie stosunkowo krótkich domen (< 5 znaków). Z tego względu ich klasyfikacja jest łatwa i ostatecznie zdecydowaliśmy, że nasz klasyfikator będzie klasyfikował domeny o minimalnej długości 3 znaków. Uzyskana precyzja okazała się wystarczająca. Krótsze subdomeny nie podlegają klasyfikacji i są one zawsze traktowane jako poprawne. 

Algorytm klasyfikacji pojedynczej subdomeny przedstawia się następująco. Dla zadanej domeny, kolejne trójznaki generowane są metodą okna przesuwnego, np. domenie
\begin{align*}
d = \texttt{tunelowanie.bcyb.com}
\end{align*}
odpowiada wektor trójznaków 
\begin{align*}
\vec{3}(d) = \left[ \texttt{tun}, \texttt{une}, \texttt{nel}, \texttt{elo}, \texttt{low}, \texttt{owa}, \texttt{wan}, \texttt{ani}, \texttt{nie} \right]
\end{align*}
W fazie trenowania obliczana jest względna częstość występowania poszczególnych trójznaków $s$ na całym zbiorze uczącym, w klasie pozytywnej $P$ i negatywnej $N$, według następującego wzoru:
\begin{align*}
f(s) = \log_2 \left( \frac{p\left(s|P\right)}{p\left(s|N\right)} \right) = \log_2 p\left(s|P\right) - \log_2 p\left(s|N\right) 
\end{align*}
Wartość $f(s)$ jest dodatnia, gdy $p(s|P) > p(s|N)$ oraz ujemna, gdy $p(s|N) > p(s|P)$. W przypadku, gdy $p(s|P) = 0$ ($s$ występuje tylko w klasie negatywnej), przyjmuje się $v(s) = -100$. Jeśli $p(s|N) = 0$ ($s$ występuje tylko w klasie pozytywnej) przyjmuje się $v(s) = 100$. W praktyce, zdecydowana większość trójznaków występuje tylko w jednej klasie, co pozwala na szybkie i jednoznaczne sklasyfikowanie większości zapytań. 

Napisany w języku R skrypt \texttt{./ips\_dns\_tunnel/bayes/train.r} generuje plik CSV, zawierający uszeregowany alfabetycznie zbiór wszystkich trójznaków wraz z odpowiadającymi im wartościami $f(s)$. Plik ten jest wczytywany przez Snorta, a następnie wykorzystywany do klasyfikacji zapytań. Dla subdomeny $d$ wyznacza się jej klasę $C(d)$, według następującego wzoru:
\begin{align*}
& C(d) = \begin{cases}
	P & \text{for} \ \text{val}(d) > \textrm{thr} \\ 
	N & \text{w.p.p.} \\
\end{cases}
\\ & \textrm{gdzie} \ \text{val}(d) = \sum_{s \in \vec{3}(d)} f(s)
\end{align*}
gdzie $\textrm{thr}$ stanowi przyjęty próg klasyfikacji. Wartość tego progu wprost wpływa na precyzję klasyfikatora, która rośnie wraz ze zwiększaniem progu. Dla $\text{thr} = 0$ mamy proste porównanie prawdopodobieństw: wybierana jest klasa o większym szacowanym prawdopodobieństwie. Dla $\text{thr} > 0$ prawdopodobieństwo klasy pozytywnej powinno być odpowiednio większe, dla zaklasyfikowania subdomeny jako złośliwej. Metodą prób i błędów, przyjęliśmy $\text{thr} = \log_2 20 \approx 4,32$, co stanowi kompromis pomiędzy brakiem fałszywych alarmów a dość szybkim blokowaniem złośliwej transmisji. 

Niestety, przygotowany klasyfikator nie może być wykorzystany w naszej wtyczce bezpośrednio. Uzyskane wartości precyzji i czułości różnią się diametralnie pomiędzy witrynami, nie będziemy więc tutaj przytaczać konkretnych liczb; oscylują one zazwyczaj pomiędzy 0,96-0,99 dla precyzji i 0,8-0,95 dla czułości. Oznacza to, że o ile zapytania złośliwe są wykrywane bardzo skutecznie (mamy 80-90\% szans na zablokowanie złośliwej transmisji już po jednym zapytaniu), to średnio kilka procent zapytań poprawnych klasyfikowanych jest jako złośliwe. Rodzi to znaczne ryzyko niestabilnego działania sieci z punktu widzenia końcowego użytkownika. Niestety, próby poprawy tego wyniku poprzez ulepszenie klasyfikatora, bez jednoczesnego radykalnego zmniejszenia czułości, są w zasadzie skazane na niepowodzenie, niezależnie od użytej metody uczenia maszynowego. Okazuje się bowiem, że w ,,naturalnych'' zapytaniach DNS również zdarza się deweloperom umieszczać dane binarne, np. kodowane szesnastkowo sumy kontrolne MD5. Przykłady takiej praktyki przedstawiono na rys. \ref{fig:badlog}. 
\begin{figure}[!h] \centering
	\includegraphics[width=0.95\linewidth]{img/badlog.PNG}
	\caption{Przykłady ,,naturalnych'' zapytań DNS zawierających kodowane dane binarne.} \label{fig:badlog}
\end{figure}

Z tego względu, niemożliwe jest odrzucanie zapytań tylko i wyłącznie na podstawie klasyfikatora Bayesa -- bardzo szybko doprowadziłoby to do zablokowania wielu zaufanych witryn. Ostateczny klasyfikator stosuje zatem rozszerzoną analizę częstotliwościową. Została ona opisana w szczegółach w następnym podrozdziale. 

\subsection{Wtyczka systemu Snort} \label{sec:implementacja-plugin}

Narzędzia służące do wykrywania tunelowania DNS znajdują się w katalogu \texttt{./ips\_dns\_tunnel}. Obok znajdujących się w podkatalogu \texttt{bayes} i opisanych już wyżej skryptów języka R, mamy kolejno podkatalogi:
\begin{itemize}
	\item \texttt{snort\_plugin}: kod właściwej wtyczki w języku C++, kompilowany (podobnie jak cały Snort) za pomocą g++ oraz CMake;
	\item \texttt{snortd}: daemon systemd (ang. \emph{systemd unit}), uruchamiający Snorta automatycznie podczas startu systemu. Działa on na hostach IPS1/IPS2 i umożliwia ich działanie w trybie inline bez dodatkowej ingerencji ze strony użytkownika. 
\end{itemize} 
Jak wskazano w rozdziale \ref{sec:implementacja-bayes}, ,,surowy'' klasyfikator Bayesa wymaga dalszych usprawnień. Ostateczny algorytm klasyfikacji realizowany przez naszą wtyczkę działa następująco:
\begin{enumerate}
	\item Dla każdej odpytywanej domeny pierwszego poziomu (np. \texttt{google.com}, \texttt{cloudflare.com}) tworzona jest tablica $T_d$ o długości $N$;
	\item wpisy w tablicy $T_d$ zawierają $N$ ostatnich \textbf{unikalnych} subdomen, odpytywanych w ramach tej domeny; wielokrotne zapytania kierowane do tej samej subdomeny, np. \texttt{www.cloudflare.com} stanowią jeden wpis;
	\item dla każdej subdomeny tabela przechowuje informację, do jakiej klasy została ona przypisana przez surowy klasyfikator Bayesa;
	\item w momencie, gdy łączna długość subdomen znajdujących się w danej tablicy i zaklasyfikowanych jako złośliwe przekroczy zadany próg $L$ znaków, cała domena pierwszego poziomu jest blokowana, a wszystkie kierowane do niej zapytania są odrzucane.
\end{enumerate}
Skuteczność tego algorytmu bierze się w faktu, że proces pojawiania się wpisów w tabeli $T_d$ można modelować (w przybliżeniu) jako proces Poissona. Przy założeniu, że prawdopodobieństwo zdarzenia typu \emph{false-positive} jest stałe i niezależne od historii zapytań\footnote{Jest to założenie w praktyce niespełnione, ale zachodzi ono w stopniu wystarczającym do działania algorytmu.}, ryzyko zablokowania zaufanej domeny daje się opisać za pomocą rozkładu Poissona.

Załóżmy, że średnia długość subdomeny w zapytaniu wynosi $z$ znaków, a prawdopodobieństwo zajścia zdarzenia typu \emph{false-positive} wynosi $p$. Liczba domen w tablicy jest równa $N$, z czego średnio $pN$ będzie zakwalifikowane jako złośliwe. Liczba $pN$ odpowiada zatem parametrowi $\lambda$ rozkładu Poissona $f(k,\lambda)$, a prawdopodobieństwo wystąpienia w tabeli dokładnie $k$ domen zakwalifikowanych jako złośliwe wynosi 
\begin{align}
f(k,pN) = \left( e^{-pN} \right) \frac{ \left( pN \right)^k }{k!}
\end{align}
Do zablokowania domeny wymagane jest co najmniej $\frac{L}{z}$ zablokowanych subdomen, zatem prawdopodobieństwo błędnego zablokowania domeny wynosi:
\begin{align} \label{eq:cumulative}
P\left( k > Lz^{-1} \right) = e^{-pN} \sum_{k = Lz^{-1}}^{N} \frac{ \left( pN \right)^k }{k!}
\end{align}
Jak wprost wynika ze wzoru \ref{eq:cumulative}, ryzyko fałszywego alarmu maleje wykładniczo wraz ze wzrostem długości tablicy $T_d$, jednocześnie jednak jej zwiększanie powoduje wzrost ilości pamięci wymaganej do działania wtyczki; należy pamiętać, że w ciągu jednego dnia użytkowania komputer osobisty jest on w stanie odpytać od kilkuset do kilku tysięcy unikalnych domen pierwszego poziomu; dka każdej takiej domeny, w pamięci RAM przechowywana jest osobna tablica. Wartości $N$ i $L$ stanowią parametry uruchomieniowe naszej wtyczki i wprost decydują o jej skuteczności w codziennym użytkowaniu. Metodą prób i błedów, za optymalną przyjęliśmy konfigurację ,,32/72'', czyli tablicę $T_d$ o długości $N = 32$ wpisy i próg blokady $L = 72$ znaki. Dla takich wartości $N$ i $L$, średniej długości zapytania równej $z = 8$ znaków oraz prawdopodobieństwie zdarzenia typu \emph{false-positive} równym $p = 2\%$, teoretyczne prawdopodobieństwo uzyskania fałszywego alarmu wynosi:
\begin{align*}
P \left( k > 9 \right) = 2.8 \cdot 10^{-8}
\end{align*}
czyli $0.0000028\%$ na zapytanie. Dla średniej ilości zapytań rzędu kilkadziesiąt tysięcy dziennie, daje to teoretycznie jeden fałszywy alarm na 1000 dni użytkowania. 

\section{Testy}

\subsection{Zapora sieciowa} \label{sec:testy-firewall}
Poprawność konfiguracji zapory sieciowej postanowiliśmy przetestować, wykonując na naszej sieci firmowej podstawowe testy penetracyjne. Testy wykonywane były na maszynie potencjalnego atakującego (MDNS) i polegały na skanowaniu sieci firmowej (10.0.0-2.0/24) za pomocą programów nmap i nessus. Przeprowadziliśmy następujące skanowania:
\begin{itemize}
	\item nmap: skanowanie SYN, które potwierdziło, że jedyne widoczne z zewnątrz porty to \texttt{s1.bcyb.com:80} i \texttt{s2.bcyb.com:80} (rys. \ref{fig:nmap});
	\item nmap: skanowanie XMAS, nie wykryło ono żadnych otwartych portów (wszystkie zostały oznaczone jako \texttt{open|filtered} -- rys. \ref{fig:nmap-xmas}); jest to zgodne z konfiguracją stanowego firewalla, który powinien zawsze odrzucać pakiety typu \texttt{invalid}; 
	\item skanowanie za pomocą skanera podatności Nessus: nie wykryto żadnych dodatkowych podatności, za pomocą których można by dokonać ataku na serwery SRV1 i SRV2 (rys. \ref{fig:nessus}).
\end{itemize}

\begin{figure}[!h] \centering
	\includegraphics[width=0.95\linewidth]{img/nmap.PNG}
	\caption{Wynik skanowania sieci firmowej metodą za pomocą nmap-a. Skanowanie pół-otwarte.} \label{fig:nmap}
\end{figure}

\begin{figure}[!h] \centering
	\includegraphics[width=0.95\linewidth]{img/nmap-xmas.PNG}
	\caption{Wynik skanowania sieci firmowej metodą za pomocą nmap-a. Skanowanie typu XMAS.} \label{fig:nmap-xmas}
\end{figure}

\begin{figure}[!h] \centering
	\includegraphics[width=0.95\linewidth]{img/nessus.PNG}
	\caption{Wynik skanowania sieci firmowej za pomocą skanera podatności Nessus.} \label{fig:nessus}
\end{figure}

Analogiczne skanowania wykonaliśmy na maszynie SRV2, w celu przetestowania konfiguracji strefy zdemilitaryzowanej. Z uwagi na znacznie większą liczbę widocznych hostów, ich pełne wyniki są obszerne i nie będziemy ich tutaj zamieszczać; istotne jest, że skanowania nie wykazały żadnych odstępstw od zakładanego działania sieci firmowej. W szczególności, blokowany jest ruch pomiędzy strefą DMZ a siecią wewnętrzną (INET). Wyjątkiem jest ruch SSH pochodzący z sieci INET, co pozwala pracownikom firmy na zarządzanie maszynami znajdującymi się w strefie zdemilitaryzowanej.


\subsection{Wtyczka systemu Snort} \label{sec:testy-wtyczka}
Weryfikacja działania wtyczki sprowadza się \emph{de facto} do oceny jakości końcowego klasyfikatora tj. oceny jego precyzji i czułości (rozdział \ref{sec:implementacja-bayes}). Testy składały się zatem z dwóch etapów: \begin{itemize}
	\item test precyzji -- ręczne przeglądanie internetu na maszynie wirtualnej USR2 przez określony czas (ok. kilku godzin);
	\item test czułości -- próba przesłania na maszynę atakującego pliku \texttt{/etc/shadow} pochodzącego z serwera SRV2, za pomocą przygotowanych skryptów nadawczego \texttt{dnsenc.sh} i odbiorczego \texttt{dnsdec.js} realizujących transmisję metodą tunelowania DNS.
\end{itemize}

Zgodnie z obliczeniami poczynionymi w rozdziale \ref{sec:implementacja-plugin}, teoretyczne prawdopodobieństwo zablokowania zaufanej domeny wynosi ok. 0,1\% na jeden dzień przeglądania. W rzeczywistości jednak założenia procesu Poissona nie są spełnione i prawdopodobieństwo fałszywego alarmu jest o ok. 3 rzędy wielkości większe. Jakkolwiek zdecydowana większośc domen jest poprawnie klasyfikowana, to skuteczność działania algorytmu jest silnie zależna od konkretnej witryny. Niektóre strony, jak np. Dropbox, wykorzystują wiele subdomen zawierających dane binarne i są szybko blokowane, niezależnie od parametrów klasyfikatora. Uzyskana precyzja jest zatem w niektórych wypadkach niewystarczająca. Niestety, jak była już mowa w rozdziale \ref{sec:implementacja-bayes}, w zasadzie nie ma możliwości jej dalszego zwiększania. Z tego względu, wyposażyliśmy naszą wtyczkę w dodatkową funkcję białej listy. W pliku \texttt{/etc/snortd/whitelist.lst} użytkownik może zdefiniować listę zaufanych domen, które nie podlegają blokowaniu. Istnieje zatem możliwość możliwość dostosowania działania wtyczki do swoich własnych potrzeb. 

Jeśli chodzi o test precyzji, to skuteczność wtyczki w tym zakresie jest nie do podważenia; jak przedstawiono na rys. \ref{fig:engrams-hist}, statystyka n-gramów dla zapytań złośliwych różni się znacznie od statystyki zapytań ,,nauralnych'' i ich odróżnienie nie stanowi trudności. Z uwagi na przyjęty próg blokady domeny $L = 72$ znaki oraz precyzję klasyfikatora rzędu 0.8-0.9, zablokowanie złośliwej transmisji następuje już po kilku zapytaniach (rys. \ref{fig:dnsenc}). Pozwala to na przesłanie co najwyżej kilkudziesięciu bajtów danych; w przypadku pliku \texttt{/etc/shadow} udało się odebrać jedynie wartość określającą rodzaj użytej funkcji skrótu, wartość ziarna soli oraz kilka pierwszych bajtów 512-bitowego skrótu hasła (rys. \ref{fig:dnsdec}). 

\begin{figure}[!h] \centering
	\includegraphics[width=0.95\linewidth]{img/dnsenc.PNG}
	\caption{Zablokowana przez Snorta transmisja pliku \texttt{/etc/shadow} z maszyny SRV2.} \label{fig:dnsenc}
\end{figure}

\begin{figure}[!h] \centering
	\includegraphics[width=0.65\linewidth]{img/dnsdec.PNG}
	\caption{Odebrany na maszynie atakującego fragment pliku \texttt{/etc/shadow}.} \label{fig:dnsdec}
\end{figure}

\section{Podsumowanie} \label{sec:summary}
Celem projektu było przygotowanie wtyczki dla systemu IDS/IPS Snort, służącej do blokowania ukrytej transmisji metodą tunelowania DNS. Pomimo doświadczonych problemów, zwłaszcza ze skuteczną klasyfikacją ,,naturalnych'' zapytań, uzyskane wyniki uznajemy za wysoce satysfakcjonujące. Dodatkowo, nie do przecenienia są rozwijające walory naszego projektu. Realizacja zadania pozwoliła nam sprawdzić w praktyce nasze umiejętności konfigurowania i zabezpieczenia przez atakami sieci korporacyjnych o nietrywialnej budowie. Mieliśmy możliwość poznania nowoczesnego systemu IDS/IPS Snort, i to zarówno od strony programisty jak i użytkownika. Dodatkowo interesujące było zastosowanie w obszarze cyberbezpieczeństwa algorytmów uczenia maszynowego i rozpoznawania tekstu. 

\printbibliography

\end{document}
